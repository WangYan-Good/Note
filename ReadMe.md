学习各种知识笔记，摘要，总结

# Interview

## 排序算法
  时间复杂度：
    θ(N2)：冒泡排序，直接插入排序，折半插入排序，选择排序
    θ(Nlog(N))：归并排序，快速排序，堆排序，
    θ(N1.3)：希尔排序
  
  稳定性：
    Y：冒泡排序，直接插入排序，折半插入排序，归并排序，基数排序
    N：希尔排序，快速排序，堆排序，简单选择排序

## 堆和栈
   _________
  |         |
  |  stack  | 先进后出，线性表，只能对栈顶进行压栈和出栈操作，用于存储临时变量，由系统自动回收
  |         | 从上往下增长，即从地址大的方向往地址小的方向增长
  |---------|
  |         |
  |   heap  | 用于存储程序员手动分配空间的变量，需要进行手动释放
  |         | 从下往上增长，即从地址小的方向往地址大的方向增长
  |---------|
  |         |
  |   bss   | 用于存储未被初始化的全局变量
  |         |
  |---------|
  |         |
  |   Data  | 存放静态变量和被初始化的全局变量
  |         |
  |---------|
  |         |
  |  code   | 存放代码
  |_________|

## 栈的应用
  括号的匹配
  迷宫求解
  进制转换
  中缀表达式转后缀表达式
  递归的替代

## 堆排序原理

## 多进程与多线程
  进程：进程是程序的一次执行过程，进程是操作系统资源分配的基本单位
  线程：线程是CPU调度和分派的基本单位，线程是任务调度和执行的基本单位

## 进程与线程间通信
  进程：
      管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
      有名管道 (namedpipe) ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
      信号量(semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
      消息队列( messagequeue ) ：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
      信号 (sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
      共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
      套接字(socket ) ：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。
      Streams：

  线程：
      锁机制：包括互斥锁、条件变量、读写锁
              互斥锁提供了以排他方式防止数据结构被并发修改的方法。
              读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
              条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
      信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
              信号机制(Signal)：类似进程间的信号处理

## 死锁
  产生的必要条件(4个)：互斥、占有且等待、不可抢占、循环等待
  避免死锁的方法：
    死锁预防 ----- 确保系统永远不会进入死锁状态
    破坏“占有且等待”条件
    破坏“不可抢占”条件
    破坏“循环等待”条件

## 计算机网络
  TCP三次握手
  第一次：客户端->服务端发送请求
  第二次：服务端->客户端响应请求
  第三次：客户端->服务端确认响应请求

  为什么不用两次握手?
  为了防止已经失效的报文突然又传送到了服务器上，从而产生错误
  例如：客户端发送请求连接没有丢失，但是滞留时间太长，客户端重新发送连接请求，第二次请求被服务端收到，完成连接
  数据传输完成之后，第一次连接请求发到达了服务器，由于没有反馈机制，服务器将处于长期等待情况，导致资源浪费

  TCP四次挥手
  第一次：客户端->服务器，发送释放连接请求，并停止发送数据，客户端进入终止等待状态
  第二次：服务器->客户端，发送请求确认响应
  第三次：服务器->客户端，发送连接释放报文，服务端进入最后确认状态
  第四次：客户端->服务器，发送确认释放响应

  为什么最后客户端还要等待 2*MSL的时间呢?
  MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
  第一：保证释放确认报文到达服务端，如果没有到达，则服务端会重新发送连接释放报文
  第二：防止类似于三次握手中已失效连接重新出现在本次连接中，2*MSL时间内，可以确保本次连接的报文都从网络中消失

## 软件的设计模式
### 创建型模式(5种)
  工厂模式、抽象工厂模式、单例模式、构建者模式、原型模式

### 结构型模式(7种)
  适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

### 行为型模式(11种)
  策略模式、模板模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。