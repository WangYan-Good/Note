第2章 语言及其文法

2-1 基本概念
  1.字母表
    字母表∑是一个有穷符号集合
      符号：字母、数字、标点符号、...
      例：
      二进制字母表：{0,1}
      ASCII字符集
      UniCode字符集
  
  2.字母表上的运算
    字母表∑1和∑2的乘积(product)
      ∑1∑2 = {ab|a∈∑1,b∈∑2}
      例：{0,1}{a,b} = {0a,0b,1a,1b}
    
    字母表∑的n次幂(power)
      ∑0 = {ε}
      ∑n = ∑(n-1)∑, n>=1
      例：{0,1}3 = {0,1}{0,1}{0,1}
         = {000,001,010,011,100,101,110,111}
      字母表的n次幂：长度为n的符号串构成的集合

    字母表∑的正闭包(positive closure)
      ∑+ = ∑∪∑2∪∑3∪...
      例：{a,b,c,d}+ = {a,b,c,d,aa,ab,ac,ad,ba,bb,bc,bd,...,aaa,aab,aac,aad,aba,abb,abc,...}
      字母表的正闭包：长度正数的符号串构成的集合

    字母表的克林闭包(Kleene closure)
      ∑* = ∑0 并∑+ = ∑0∪∑∪∑2∪∑3∪...
      例：{a,b,c,d}* = {ε,a,b,c,d,aa,ab,ac,ad,ba,bb,bc,bd,...,aaa,aab,aac,aad,aba,abb,abc,...}
      字母表的克林闭包：任意符号串(长度可以为零)构成的集合

  3.串
    设∑是一个字母表，任意x∈∑*，x称为是∑上的一个串
      串是字母表中符号的一个有穷序列
    串s的长度，通常记作|s|，是指s中符号的个数
      例：|aab| = 3
    空串是长度为0的串，用ε(epsilon)表示
      |ε| = 0

  4.串上的运算--链接
    如果x和y是串，那么x和y的连接(concatenation)是把y附加到x后面而形成的串，记作xy
      例如：如果x = dog且y=house,那么xy = doghouse
      空串是连接运算的单位元(identity)，即，对于任何串s都有，εs = sε = s
      设x,y,z是三个字符串，如果x=yz，则称y是x的前缀，z是x的后缀

  5.串上的运算--幂
    串s的幂运算
      s0 = ε
      sn = s(n-1)s, n>=1

      s1 = s0s = εs = s, s2 = ss, s3 = sss, ...
      例：如果s=ba，那么s1=ba,s2=baba,s3=bababa, ...
      串s的n次幂：将n个s连接起来
2-2 文法定义
  1.自然语言例子--句子的构成规则
    <句子> -> <名词短语> <动词短语>
    <名词短语> -> <形容词><名词短语>
    <名词短语> -> <名词>
    <动词短语> -> <动词> <名词短语>
    <形容词> -> little
    <名词> -> boy
    <名词> -> apple
    <动词> -> eat

    尖括号括起来的部分称为语法成分
    未用尖括号括起来的部分表示语言的基本符号

  2.文法的形式化定义
    G = ( Vt, Vn, P, S )
    Vt:终结符集合         Vt∩Vn=空
    Vn:非终结符集合       Vt∪Vn：文法符号集
    非终结符(nonterminal) 是用来表示语法成分的符号
    有时也称为“语法变量”
    例：Vn = { <句子>, <名词短语>, <动词短语>, <名词>, ... }

    P:产生式集合
    产生式(production)描述了将终结符和非终结符组合成串的方法。
    产生式的一般形式：α -> β
    读作：α定义为β
    α∈( Vt∪Vn )+, 且α中至少包含Vn中的一个元素：称为产生式的头(head)或左部(left side)
    β∈( Vt∪Vn )*：称为产生式的体或右部(right side)
    例：P = { <句子>-><名词短语><动词短语>,   }
            { <名词短语>-><形容词><名词短语>, }
            {     ...                         }
    
    S:开始符号
    S∈Vn。开始符号( start symbol )表示的是该文法中最大的语法成分
    例：S = <句子>

    例：G=( {id, +, *, (, )}, {E}, P, E )                                     G: E->E+E
	P = { E->E+E,                                                            E->E*E
              E->E*E,                             ------------------------->     E->(E)
              E->(E),                                                            E->id
              E->id  }
    约定：不引起歧义的前提下，可以只写产生式

  3.产生式的简写
    对一组相同左部的α产生式：α->β1, α->β2, α->β3, ... , α->βn
    可以简记为: α-> β1|β2|β3|...|βn
    读作：α定义为β1，或者β2，... ，或者βn
    β1，β2，... βn称为α的候选式(candidate)
    例：E->E+E             
        E->E*E   -------->  E->E+E|E*E|(E)|id
	E->(E)
	E->id
       
  4.符号约定
    下述符号式终结符
    (a)字母表中排在前面的小写字母，如a，b，c
    (b)运算符，如+、*等
    (c)标点符号，如括号、逗号等
    (d)数字0，1，... ，9
    (e)粗体字符串，如id、if等

    下述符号式非终结符
    (a)字母表中排在前面的大写字母，如A，B，C
    (b)字母S，通常表示开始符号
    (c)小写、斜体的名字，如expr，stmt等
    (d)代表程序构造的大写字母，如E(表达式)、T(项)和F(因子)

    字母表中排在后面的大写字母(如X，Y，Z)
    表示文法符号(即终结符或非终结符)

    字母表中排在后面的小写字母(主要是u、v、... 、z)
    表示终结符号串(包括空串)

    小写希腊字母，如α，β，γ表示文法符号串(包括空串)

    除非特别说明，第一个产生式的左部就是开始符号

    -----------------------------------------------
    | 终结符    a,b,c   | 终结符号串 u,v, ... ,z  |
    | 非终结符  A,B,C   |                         |
    | 文法符号  X,Y,Z   | 文法符号串 α，β，γ   |
    -----------------------------------------------

2-3 语言的定义
  1.自然语言的例子
    文法：
    <句子> -> <名词短语> <动词短语>
    <名词短语> -> <形容词><名词短语>
    <名词短语> -> <名词>
    <动词短语> -> <动词> <名词短语>
    <形容词> -> little
    <名词> -> boy
    <名词> -> apple
    <动词> -> eat

    单词串：little boy eats apple

    有了文法(语言规则)，如何判断一个词串是否是满足文法的句子？

  2.推导(derivations)和归约(Reductions)
    给定文法G = ( Vt, Vn, P, S )，如果α->β∈P, 那么可以将符号串γαδ中的α替换为β，也就是说，将γαδ重写(rewrite)为γβδ
    记作γαδ->γβδ。此时，称文法中的符号串γαδ直接推导(directly derive)出γβδ

    简而言之，就是用产生式的右部替换产生式的左部

    如果α0-> α1, α1->α2, α2->α3, ... , αn-1 --> αn
    可以记作α0->α1->α2->α3->...->αn-1->αn，则称号串α0经过n步推导出αn，
    可简记为α0->n αn

    α->0 α
     
    ->+ 表示"经过正数步推导"
    ->* 表示"经过若干(可以是0)步推导"

    例：
    <句子> -> <名词短语> <动词短语>         | <句子> -> <名词短语><动词短语>
    <名词短语> -> <形容词><名词短语>        |        -> <形容词><名词短语><动词短语>
    <名词短语> -> <名词>                    |        -> little<名词短语><动词短语>
    <动词短语> -> <动词> <名词短语>         |        -> little<名词><名词短语>
    <形容词> -> little                      |        -> little boy <动词短语>
    <名词> -> boy                           |        -> little boy <动词><名词短语>
    <名词> -> apple                         |        -> little boy eats <名词短语>
    <动词> -> eat                           |        -> little boy eats <名词>
                                            |        -> little boy eats apple
                 			    |        自顶向下为推导    自底向上为规约

    "有了文法(语言规则)，如何判断一个词串是否是满足文法的句子？"
    句子的推导(派生) - 从生成语言的角度
    句子的规约       - 从识别语言的角度

  3.句型和句子
    如果S->*α，α∈( Vt∪Vn )*，则称α是G的一个句型(sentential form)
      一个句型既可以包含终结符，又可以包含非终结符，也可能是空串

    如果S->* w, w∈Vt*， 则称w是G的一个句子(sentence)
      句子是不包含非终结符的句型
    例：
 <句子> -> <名词短语><动词短语>                   |
        -> <形容词><名词短语><动词短语>           |
        -> little<名词短语><动词短语>             |
        -> little<名词><名词短语>                 |   句型 
        -> little boy <动词短语>                  |
        -> little boy <动词><名词短语>            |
        -> little boy eats <名词短语>             |
        -> little boy eats <名词>                 |
  "句子"-> little boy eats apple                  |   

  4.语言的形式化定义
    由文法G的开始符号S推导出的所有句子构成的集合称为文法G生成的语言，记为L(G)。
    即：L(G) = { w|S->* w,w∈Vt* }
    例：
    文法G
    (1) S-> L|LT
    (2) T-> L|D|TL|TD
    (3) L-> a|b|c|...|z
    (4) D-> 0|1|2|3|...|9
    该文法生成的语言：标识符

  5.语言上的运算
    ---------------------------------------------
    |     运算      |    定义和表示             |  
    ---------------------------------------------
    |   L和M的并    | L∪M = { s|s∈L || s∈M } |
    ---------------------------------------------
    |  L和M的连接   | LM = {st|s∈L且t∈M}      |
    ---------------------------------------------
    |    L的幂      | L0 = {ε}                 |
    |               | Ln = (Ln-1)L, n>=1        |
    ---------------------------------------------
    | L的Kleene闭包 | L* = ∪Li                 |
    ---------------------------------------------
    |  L的正闭包    | L+ = ∪Li                 |
    ---------------------------------------------

    例：令L={A,B,...,Z,a,b,c,...,Z} D={0,1,2,...,9}。则L(L∪D)*表示的语言是标识符

2-4 文法的分类
  1.Chomsky文法分类体系
    0型文法(Type-0 Gtammer)
    1型文法(Type-1 Grammer)
    2型文法(Type-2 Grammer)
    3型文法(Type-3 Grammer)

  2.0型文法(Type-0 Grammer)
    无限制文法(Unrestricted Grammer)/短语结构文法(Phrase Structure Grammer,PSG)
    任意α->β∈P, α中至少包含1个非终结符
    
    0型语言
    由0型文法G生成的语言L(G)


  3.1型文法(Type-1 Grammer)
    α->β
    上下文有关文法(Context-Sensitive Grammar, CSG)
      任意α->β∈P,|α|<= |β|
      产生式的一般形式：α1Aα2-->α1βα2(β!= ε)

    上下文有关语言(1型语言)
      由上下文有关文法(1型文法)G生成的语言L(G)

  4.2型文法(Type-2 Grammar)
    α->β
    上下文无关文法(Context-Free Grammar, CFG)
      任意α->β∈P,α∈Vn
      产生式的一般形式:A->β
    例：
    (1) S-> L|LT
    (2) T-> L|D|TL|TD
    (3) L-> a|b|c|...|z
    (4) D-> 0|1|2|3|...|9   
    
    上下文无关语言(2型语言)
      由上下文无关文法(2型文法)G生成的语言L(G)

  5.3型文法
    α->β
    正则文法(Regular Grammar, RG)
      右线性(Right Linear)文法:A->wB 或 A->w
      左线性(Left Linear)文法:A->Bw 或 A->w
      左线性文法和右线性文法都称为正则文法
    例(右线性文法)
    (1)S->a|b|c|d
    (2)S->aT|bT|cT|dT
    (3)T->a|b|c|d|0|1|2|3|4|5
    (4)T->aT|bT|cT|dT|0T|1T|2T|3T|4T|5T
    
    正则语言(3型语言)
      由正则文法(3型文法)G生成的语言L(G)
      正则文法能描述程序设计语言的多数单词

  6.四种文法之间的关系
    逐级限制
      0型文法：α中至少包含一个非终结符
      1型文法(CSG)：|α|<|β|
      2型文法(CFG)：α∈Vn
      3型文法(RG)：A->wB or A->w (A->Bw or A->w)
       
    逐级包含
    -----------------------------------------------
    |         0型文法集合                          |
    |  ------------------------------------------  |
    |  |      1型文法集合                       |  |
    |  |  ------------------------------------  |  |
    |  |  |   2型文法集合                    |  |  |
    |  |  |   --------------------------     |  |  |
    |  |  |  | 3型文法集合              |    |  |  |
    |  |  |  |                          |    |  |  |
    |  |  |   --------------------------     |  |  |
    |  |  -----------------------------------   |  |
    |  -----------------------------------------   |
    -----------------------------------------------  

2-5 上下文无关文法(Context-Free Grammar, CFG)的分析树
  1.CFG分析树
    G:
    (1)E->E+E           |                              E
    (2)E->E*E           |           |--------------------------------|
    (3)E->-E            |           -                                E
    (4)E->(E)           |                                   |--------|-------------|         
    (5)E->id	        |                                   (        E             )
	                |                                        |---|-----|
		                                                 E   +     E
    根节点的标号为文法开始符号
    内部结点表示对一个产生式A->β的应用，该结点的标号是此产生式左部A。该结点的子结点的标号从左到右构成了产生式的右部β
    叶节点的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点得到的符号串称为是这棵树的产出(yield)或边缘(frontier)

  2.分析树是推导的图形化表示
      给定一个推导S->α1->α2->...->αn,对于推导过程中得到的每一个句型αi，都可以构造出一个边缘为αi的分析树
    
    推导过程：E -> -E -> -(E) -> -(E+E) -> -(id+E) -> -(id+id)
    文法：              |  分析树：
    (1)E->E+E           |                              E
    (2)E->E*E           |           |--------------------------------|
    (3)E->-E            |           -                                E
    (4)E->(E)           |                                   |--------|-------------|         
    (5)E->id	        |                                   (        E             )
	                |                                        |---|-----|
		                                                 E   +     E
								 |         |
								 id        id

  3.(句型的)短语
    给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个短语(phrase)
      如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语(immediate phrase)
    文法：              |  分析树：                                                          |  短语：      直接短语：
    (1)E->E+E           |                              E                                     |      -(E+E)            E+E
    (2)E->E*E           |           |--------------------------------|                       |      (E+E)
    (3)E->-E            |           -                                E                       |      E+E
    (4)E->(E)           |                                   |--------|-------------|         | 
    (5)E->id	        |                                   (        E             )         |
	                |                                        |---|-----|                 |
		        |                                        E   +     E                 |
    直接短语一定是某产生式的右部
    但产生式的右部不一定是给定句型的直接短语
    例：
    (1)<句子>-><动词短语>
    (2)<动词短语>-><动词><名词短语>
    (3)<名词短语>-><名词><名词短语> | <名词>
    (4)<动词>->提高
    (5)<名词>->高人|人民|民生|生活|活水|水平
    输入：提高人民生活水平
                                         <句子>
					    |
				       <动词短语>
				 ---------------------
				|                     |
			     <动词>               <名词短语>
		   --------------         -------------------------
		  |              |       |                         |
		  |              |     <名词>                 <名词短语>
		  |              |   ---------         ---------------------------
		  |              |  |         |       |                           |
		  |              |  |         |    <名词>                     <名词短语>
		  |              |  |         |   -----------                     |
		  |              |  |         |  |           |                  <名词>
		  |              |  |         |  |           |                -----------
		  |              |  |         |  |           |                |          |
		  提            高  人       民  生         活               水          平

  4.二义性文法(Ambiguous Grammar)
    如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的
    例：
    文法：
    S-> if E then S           |
       |if E then S else S    | 条件语句
       |other                 <-- 其他语句
    
    句型
    if E1 then if E2 then S1 else S2

                S                             |                  S
    ---------------------------------         |   ------------------------------------------------------------
   |         |             |         |        |   |      |          |          |             |                |
  if         E1           then       S        |   if     E1        then        S            else              S2
                 --------------------|------  |              ------------------|---------------------
		 |    |     |   |    |      | |              |                 |      |              |
		if   E2   then S1   else   S2 |             if                 E2    then            S1
    
    消歧规则：每个else和最近的尚未匹配的if匹配
  
  5.二义性文法的判定
    对于任意一个上下文无关文法，不存在一个算法，判定它是无二义性的；但能给出一个充分条件，满足这组充分条件的文法是无二义性的
    满足，肯定无二义性
    不满足，也未必就是有二义性的  
