# Linux从入门到精通概要笔记

## 第四章 桌面环境

### 4.1 快速熟悉你的工作环境

#### 4.1.1 运行应用程序

（1）所有应用程序均安放在“应用程序”的下拉菜单中

#### 4.1.2 浏览文件系统

（1）可以使用类似Windows下的“资源管理器”的工具浏览整个硬盘。

（2）双击目标可以访问该目录，也可以在搜索栏中输入具体的路径名来访问。

#### 4.1.3 创建一个文本文件

（1）右击桌面，选择“创建文档”命令

（2）Ubuntu附带编辑器**gedit**，默认采用UTF-8编码，编码选择在数据库录入数据时尤为重要。

### 4.2 个性化设置

#### 4.2.1 桌面背景和字体

（1）右击桌面，在弹出的快捷菜单中可以选择“更改桌面背景”命令。

（2）通过“+”自由选择添加本地文件壁纸

（3）若要设置字体，则需要现在Ubuntu软件中心安装好高级设置。在弹出的Advanced Ssttings对话框设置字体。

#### 4.2.2 显示器分辨率

（1）通过“设置”按钮，选择“显示”命令，可根据实际选择分辨率

#### 4.2.3 代理服务器

（1）如果计算机需要通过内网的代理服务器连接到互联网，就让系统知道这台服务器。

（2）单击“系统设置”命令，打开对话框。选择“网络”对话框，选择“网络代理”命令。

#### 4.2.4 鼠标和键盘

#### 4.2.5 键盘快捷键

### 4.3 进阶：究竟什么是“桌面”

#### 4.3.1 可以卸载的图形环境

（1）在内核眼中，图形环境只是一个普通的应用程序，和其他的服务器程序没什么不同

#### 4.3.2 X窗口系统的基本组成

X窗口系统（X Windows System）是Linux图形用户环境的基础。X系统基于一种独特的服务器/客户机架构。

（1）X服务器：用于实际控制输入设备（例如键盘和鼠标）和位图式输出设备（例如显示器）

（2）X客户端程序：需要向X服务器请求服务的程序。

（3）窗口管理器（Windows Manager）：负责控制应用程序窗口的各种行为。

（4）显示管理器（Display Manager）：提供一个登陆界面

（5）widget库：定义了一套图形用户界面的编程接口。

（6）桌面环境：把与X有关的东西（除了X服务器）整合在一起。

#### 4.3.3 X系统的启动过程

整个过程基本是由显示管理器（Display Manager）完成的

（1）启动X服务器

（2）提供一个界面友好的屏幕，等待验证用户身份

（3）执行用户的引导脚本

#### 4.3.4 启动X应用程序

X窗口基于服务器/客户机架构，即C/S架构，根据环境变量DISPLAY设置进行输出，例如：

DISPLAY = servername:3.2

一般的PC机的设置一般为：

DISPLAY = servername:0.0 简写为：DISPLAY = servername:0

#### 4.3.5 桌面环境：KED和Gnome谁更好

KDE(K桌面环境)是用C++编写的，基于Qt库，比较受用于Windows或Mac转Linux的用户习惯。

Gnome使用C语言编写的，基于GTK+widget库。它更加和简洁。

### 4.4 小结

## 第五章 Shell基本命令

### 5.1 Shell简介

命令行指的是提供用户输入命令的界面，本身接受输入，然后将命令传递给命令解释器。

Shell就是命令解释器，它本身是一个程序，它在用户和操作系统之间提供了一个可面向行的可交互接口。用户在命令行中输入命令，Shell把命令转换成指令代码发送给操作系统。

### 5.2 印刷约定

普通用户命令输入以“$”开始

特权用户即Root用户命令输入以“#”开头

### 5.3 快速上手：浏览你的硬盘

查看当前目录内容命令：

```shell
ls
```

选择某个文件夹进入，以home为例：

```shell
cd /home
```

可以使用不带任何参数的cd命令进入用户主目录

存放系统以及绝大部分应用软件的配置文件的文件夹：/etc

进入配置文件夹的命令：

```shell
cd /etc
```

利用fstab查看硬盘各分区挂载点：

```shell
cd /etc
cat fstab
```

5.4 提高效率：使用命令行补全和通配符

文件名是命令中最常见的参数，利用<TAB>键可以自动补全文件名，例如

```shell
cat fs<TAB>
```

Shell将会自动将其补全为：

```shell
cat fstab
```

如果已键入的字符开头的文件不止一个，那么可以连续按下<TAB>键两次，Shell会以列表的形式给出所有以键入字符开头的文件

同时，命令行补全也适用于所有Linux命令。

Shell有一套被称作通配符的专用符号，“*”，“？”，“[]”,这些通配符可以搜索并匹配的一部分。从而大大简化命令的输入。

“*”用于匹配文件名中任意长度的字符串。例如需要列出目录文件中所有C++文件：

```shell
ls *.cpp
```

“?”和“*”相似，但是“？”只能匹配一个字符，例如“？”用于匹配文件名中以test开头而后跟一个字符的文件：

```shell
ls test?
```

“[]”用于匹配所有出现在方括号内的字符。例如列出以text开头仅以1或A结束的文件名：

```shell
ls text[1A]
```

也可以使用短线“-”来指定一个字符集范围。所有包含在上下界之间的字符都会被匹配。例如列出所有以text开头并以1-3中某个字符（包括1和3）结束的文件:

```shell
ls text[1-3]
```

也可以使用字母范围，匹配A-Z范围内的大写字母：

```shell
ls text[A-Z]
```

### 5.5 查看文件和目录

#### 5.5.1 显示当前目录：

```shell
pwd
```

#### 5.5.2 改变目录：

```shell
cd
```

进入上一层目录：

```shell
cd ..
```

进入根目录：

```shell
cd ../..
```

进入用户主目录：

```shell
cd 
```

或者   

```shell
cd ～
```

#### 5.5.3 列出目录内容：

```shell
ls
```

ls基本语法：

```shell
ls [Option]… [File]…
```

罗列出当前目录下所有文件和子目录：

```shell
ls
```

*利用ls显示当前列表内容，在默认情况下，目录(/)显示为蓝色，普通文件显示为黑色，可执行文件(*)显示为草绿色，链接文件(@)显示为淡蓝色。利用参数 -F可以显示每个文件的属性标识符：

```shell
ls -F
```

罗列出当前目录下的隐藏文件：

```shell
ls -a
```

*命令的选项可以组合使用

查看文件的各种属性：

```shell
ls -l
```

ls后跟上路径名可以查看该子目录中的内容，例如：

```shell
ls    /home
```

#### 5.5.4 列出目录内容：

```shell
dir 和 vdir
```

在Linux中，dir比ls的功能更少，其他都是一样的，例如：

```shell
dir /home
```

vdir相当于为ls命令加上-l选项，默认情况下列出目录和文件的完整信息。

#### 5.5.5 查看文本文件：

```shell
cat 和 more
```

cat 命令通常用于查看文件内容（通常是一个文本文件），后跟文件名作为参数。

cat 可以跟多个文件名作为参数，当然也可以使用通配符。

对程序员而言，为了调试方便，cat提供了-n选项，在每一行前显示行号。

cat会一次性将所有命令全部显示在屏幕上，对于长达几页或者几十页的文件，cat显得毫无用处。

为此，Linux提供more命令来一页一页地显示文件内容。在按页操作中，按空格键翻页，按Enter键向下滚动一行，按Q键退出。

#### 5.5.6 阅读文件爱的开头和结尾：

```shell
head和tail
```

另外两个用来查看文件的命令是head和tail。分别用于显示文件的开头和结尾。可以使用-n参数来指定显示的行数。

例如：表示显示Files_1以及Files_2的前两行，

```shell
head -n 2 [Files_1] [Files_2]
```

例如：表示显示File_1和Files_2的最后两行

```shell
tail -n 2 [Files_1] [Files_2]
```



#### 5.5.7 更好的文本阅读工具：

```shell
less
```

less和more非常相似，但是功能更为强大。less改进了more的很多细节，并且添加了许多的特性。这些特性让less看起来更像是一个文本编辑器—只是去掉了文本编辑功能。总的来说，less命令提供了以下增强功能：

使用光标键在文本文件中前后（甚至左右）滚屏。

用行号或百分比作为书签浏览文件

实现复杂的检索，高亮显示等操作。

兼容常用的字处理程序（Emacs，Vim）的键盘操作。

阅读到文件结束时less命令不会退出。

屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。例如：

```shell
less    [File]
```

less屏幕底部显示一个冒号”:”等待命令输入，按空格键向下翻页，按B键向下翻页，利用光标键实现上下左右移动。

如果要搜索一段字符串，使用正斜杠“/”加上查找内容，less将会把找到的第一个目标高亮显示。若要继续查找相同的内容，只需要再次输入正斜杠“/”，按下回车键即可。

利用参数-M可以显示更多文件信息，less在输出的底部显示了这个文件的名字，当前页码，总的页码，以及当前位置在整个文件中的百分比数值。最后按下Q键即可退出当前界面并返回Shell提示符。

#### 5.5.8 查找文件内容：

```shell
grep
grep [OPTIONS] PATTERN [FILE..]
```

例如：在文件day中寻找包含un的行：

```shell
grep un day
```

grep有两个不同的参数，第一个是被搜索的模式（关键词），第二个是所搜索的文件。grep可以将文件中出现的关键词的行输出。可以指定多个文件来搜索，例如：grep un day weather

如果要搜索Red Hat这样的关键词，则需要在包含空格的短语前后加上单引号。例如：

```shell
grep ‘struct list’ [File]
```

严格的说，grep通过“基础正则表达式”进行搜索。和grep相关的工具是egrep,除了使用“扩展的正则表达式”之外，egrep与grep完全一样。“扩展正则表达式”比“标准正则表达式”更完整地表达规范。

### 5.6 我的东西在哪—find命令

find命令的基本语法如下：

```shell
find [OPTION] [Path…] [Expression]
```

例如，希望在/usr/bin/目录下寻找zip命令：

```shell
find /usr/bin/ -name zip -print
```

find需要一个路径名作为查找范围，find会深入该路径中的每个子目录去寻找，因此如果指定”/”,那么就查找整个文件系统。

-name选项指定了文件名，在这里是zip，也可以使用通配符来指定文件。

-print表示将结果输出到标准输出（这里也就是指屏幕）。

find命令会打印查找文件的绝对路径。

find命令还能够指定文件的类型。在Linux中，包括目录和设备都以文件的形式表现，可以使用-type选项来定位特殊文件。

例如：在/etc/目录中查找名叫init.d的目录：

```shell
find */etc -name init.d -type d -print
```

*表5.1 find**命令-type**选项可供使用的参数*

| 参数 | 含义         | 参数 | 含义     |
| ---- | ------------ | ---- | -------- |
| b    | 块设备文件   | f    | 普通文件 |
| c    | 字符设备文件 | p    | 命名管道 |
| d    | 目录文件     | l    | 符号链接 |

还可以通过指定时间来指导find命令查找文件。

-atime n用来查找最后一次使用在n天前的文件，-mtime n 用来查找最后一次修改在n天前的文件。但在实际操作中，很少能准确确定n的大小，在这种情况下，可以用+表示大于n，-n表示小于n。

例如，在文件夹/usr/bin中查找近100天没有使用过的命令：

```shell
find */usr/bin -type f -atime +100 -print*
```

类似的，下面这个命令，表示查找当前目录中，在最近一天修改过的文件

```shell
find . -type f -mtime -1 -print
```

### 5.7 更快速的的定位文件：locate命令

```shell
locate [file]
```

locate通过检索文件名数据库来确定文件位置。locate通过自动建立文件名数据库，不需要通过用户插手。

如果希望立刻生成最新版本的数据库文件，则可以使用updatadb命令，该命令需要root权限。

### 5.8 从终端运行程序

从终端运行程序只需要输入程序名即可，例如运行火狐浏览器：firefox

按Enter键之后，当前终端会被挂起，直至firefox运行完毕。

**若希望在启动应用程序后继续在终端工作，则命令后加上“&”，指导程序在后台进行。**例如：firefox &

### 5.9 查找特定程序：whereis

whereis命令主要用于查找程序文件，并提供这个文件的二进制可执行文件，源代码文件以及使用手册页存放的位置。例如，查找法find命令：

```shell
whereis find
```

也可以使用-b选项只查找这个二进制的可执行文件，例如：

```shell
whereis -b find
```

如果过whereis找不到对应文件，则会返回一个空字符串。

### 5.10 用户及版本信息查看

who命令可以查看当前系统中有哪些人登陆，以及他们都登陆在哪座控制台上。

有时候我们可能会忘记自己的登陆名称，利用whoami命令可以解决该问题。

另一个常用的命令是uname，用于显示当前系统版本信息。带-a选项的uname会给出当前系统所有的有用信息。而-r选项只会显示其中的内核版本信息。

### 5.11 寻求帮助—man命令

Linux中几乎为每一个命令和系统调用编写了用户手册，使用man命令可以方便的获取某个命令的帮助信息，例如：

```shell
man find
```

man命令在显示手册页时实际调用的是less程序。可以通过方向键或者J键（表示向下），K（表示向上）键向上翻动。空格键用于向下翻动一页。按下Q键则退出手册页面。man手册一般被分为9节，各部分内容如下表所示：

表5-2 man手册的组织

| 目录                  | 内容                               |
| --------------------- | ---------------------------------- |
| */usr*/share/man/man1 | 普通命令和应用程序                 |
| */usr*/share/man/man2 | 系统调用                           |
| */usr*/share/man/man3 | 库调用，主要是libx()函数的使用文档 |
| */usr*/share/man/man4 | 设备驱动和网络协议                 |
| */usr*/share/man/man5 | 文件的详细格式信息                 |
| */usr*/share/man/man6 | 游戏                               |
| */usr*/share/man/man7 | 文档使用说明                       |
| */usr*/share/man/man8 | 系统管理命令                       |
| */usr*/share/man/man9 | 内核源代码或模块的技术标准         |

 

### 5.12 获取命令简介：whatis 和 apropos

man中的命令比较详细繁琐，大多数时候人们可能只关心一个命令大概能做什么，此时用命令whatis比较合适。例如：

```shell
whatis uname
```

whatis从某个程序的使用手册中抽出一行简单的介绍性文字，帮助用户了解这个程序的大致用途。whatis原理与locate命令基本一致。

与之相反的命令是apropos，这个命令可以通过使用手册中反查到某个命令。例如想要搜索一个文件，但是又想不起来使用哪个命令的时候，可以求助apropos，例如：apropos search

 

# 第六章 文件目录管理

### 6.1 Linux文件系统的架构

Linux的目录结构组织形式与Windows有很大不同，Linux没有C盘，D盘等盘符，Linux将已经建立文件系统的硬盘分区挂载到某个目录下，用户通过操作目录来实现磁盘读写。

表6.1 Linux系统主要目录及其内容

| 目录   | 内容                                   |
| ------ | -------------------------------------- |
| /bin   | 构建最小系统所需要的命令(最常用的命令) |
| /boot  | 内核与启动文件                         |
| /dev   | 各种设备文件                           |
| /etc   | 系统软件的启动和配置文件               |
| /home  | 用户的主目录                           |
| /lib   | C编译器的库                            |
| /media | 可移动介质的安装点                     |
| /opt   | 可选的应用软件包（很少使用）           |
| /proc  | 进程的映像                             |
| /root  | 超级用户root的主目录                   |
| /sbin  | 和操作系统有关的命令                   |
| /tmp   | 临时文件存放点                         |
| /usr   | 非系统的程序和命令                     |
| /var   | 系统专用的数据和配置文件               |

 

### 6.2 快速上手：和你的团队共享文件

对一个团队而言，共享文件能够方便快捷的供团队各成员使用与修改。

一个团队可以有不同的成员，即不同用户在一个用户组之中。例如新建一个名为workgroup的用户组：

```shell
sudo groupadd workgroup
```

新建用户，并将用户归入workgroup组中：

```shell
sudo useradd -G workgroup [username]
```

为该用户设置登陆密码：

```shell
sudo passwd [passwd]
```

在/home下建立一个名为work的目录，作为小组的工作目录：

```shell
cd /home   #进入/home目录
sudo mkdir work    #建立work目录
```

任何用户都以访问该目录，但是只有Root用户才拥有该目录的写权限，以下操作是的workgroup组用户能够对该目录进行读写，且其他用户无法查看该目录。

```shell
Sudo chgrp workgroup work/    #将work目录的所有权交给workgroup组
sudo chmod g+rwx work/       #增加workgroup组对该目录的读写执行权限
sudo chmod o-rwx work/        #撤销其他用户对work目录的读写执行权限
```

接下来将该目录交给组长，即将该目录所有者修改为组长名

```shell
sudo chown [username] work/
```

此时，workgroup组成员对work目录下都可以进行读写，例如用户a可以在work目录下新建一个test文件夹，用户b可以删除这个文件夹，例如：

```shell
su a    #切换到用户a
cd */home /work*
*touch test   #**建立一个空文件夹爱touch*
*su b    #**切换到用户b*
*cd /home /work*
*rm test     #**删除test**文件夹*
```

### 6.3 建立文件和目录

#### 6.3.1 建立目录：mkdir

mkdir命令可以一次建立一个或多个命令，例如在主目录中建立document,picture两个目录：

```shell
cd ～       #进入用户主目录
mkdir document picture    #建立目录
```

用户也可以使用绝对路径来新建目录

```shell
mkdir ~/picture/temp      #在主目录下新建名为temp的目录
```

由于主目录下picture已经存在，因此上条命令是合法的，若对应绝对路径中的文件夹不存在，则mkdir将会提示错误。其中，mkdir提供了-p选项，能够完整的创建一条目录结构，例如：

```shell
mkdir -p ~/tempx/job
```

mkdir会在主目录下创建tmepx目录，然后在tempx目录中创建job目录。

#### 6.3.2 建立一个空文件：touch

touch命令的使用非常简单，在该命令后跟上一个文件名作为参数即可，例如在当前目录下新建一个hello文件：

```shell
touch hello
```

利用touch命令创建的是个空文件，在某些特定的实验环境中有用。当某些应用程序因为缺少某个文件而无法启动，并且该文件在整个程序中并不重要时，可以以建立一个空文件暂时“骗过”该程序。

touch的另一个作用是更新文件的建立日期和时间。

### 6.4 移动、复制和删除

#### 6.4.1 移动和重命名：mv

mv采取了move的缩写形式，改命令可以用来移动文件,例如下面这条命令将hello文件移动到bin目下：

```shell
mv hello bin/
```

mv命令也可以移动目录，下面这个命令可以将Photos目录移动到桌面：

```shell
mv Photos/ 桌面/
```

mv命令执行过程中不会有任何信息显示，如果遇到同名目录文件会如何呢？

（1）在主目录中建立一个名为test的目录

```shell
cd ~
mkdir test
cd test/
```

（2）建立一个名为hello的文件。这里使用重定向新建了一个文件，然后将字符串Hello输入这个文件中。

```shell
echo “Hello” > hello
cat hello
```

（3）回到主目录，创建一个名为hello的空文件

```shell
cd ..
touch hello
```

（4）将这个hello文件移动到test文件目录下。之后打开hello文件，发现该文件是个空文件，也就是说，空文件hello将之前带有信息内容的hello替换了，并且没有给出任何提示。

```shell
Mv hello test/
cd test/
cat hello
```

用户可能在不经意间就将一个重要文件删掉了，为此mv提供了-i选项用于发现这样的情况,如果存在同名文件，会给出警示，例如：

```shell
mv -i hello test/
```

mv：是否覆盖”test/hello”?

回答y表示覆盖，回答n表示跳过该文件。

另一个比较有用的选项是-b。该选项在移动文件前会在目标目录的同名文件的文件名后加一个“～”，从而避免文件被覆盖。

```shell
mv -b hello test/
```

Linux中没有“重命名”命令，重命名无非是将一个文件在同一个目录里移动，这是mv最擅长的工作。

```shell
mv hello~ hello_bak
```

#### 6.4.2 复制文件和目录：cp

cp命令用来复制文件和目录下面这条命令将文件test.php复制到test目录下：

```shell
cp test.php test/
```

与mv命令一样，在默认情况下，cp会覆盖目标文件中的同名文件。可以使用-i选项对这种情况进行提示，或者使用-b选项对同名文件修改后再复制。

cp在执行命令时会自动跳过目录。可以使用-r命令将子目录连同其中的文件一起复制到另一个子目录下，例如：

```shell
cp -r test/ 桌面/
```

#### 6.4.3 删除目录和文件：rmdir和rm

rmdir用于删除目录，后面跟上需要删除的目录名称即可，例如：

```shell
mkdir remove
rmdir remove
```

但是rmdir只能用于删除空目录，当目录内容不为空时会出错。

因此在使用rmdir删除一个目录之前，需要先删除该目录中的子目录和子文件。

rm命令可以一次删除一个或几个命令，下面这个命令可以一次删除test目录下所有php文件：

```shell
rm test/*.php
```

同mv命令一样，rm执行时不会有任何提示，且使用rm删除的文件会永久从系统中消失，而不会放在一个被称作“回收站”的临时目录下。

一个比较安全的方式是使用-i选项，用户在删除时会有提示：rm -i [filename]

回复y表示确认删除，n表示跳过这个文件。对于只读文件，即便没有加上-i 选项，rm命令也会对此进行提示。

对于只读文件的删除，可以使用-f选项避免交互式操作，rm会自动对这些问题回答y。

对于含有子目录和文件的目录，使用-r参数，rm会递归地删除目录下所有的文件和子目录。例如：下面这个命令会删除Photos目录下所有的目录，子目录以及子目录下的文件和子目录...最后删除Photos目录。最终将Photos目录完整的从磁盘上移除。

```shell
rm -r Photos/
```

### 6.5 文件和目录的权限

#### 6.5.1 权限设置针对的用户

Linux是个多用户的操作系统，正确地设置文件权限非常重要。

Linux为三种人准备了权限-文件所有者（属主），文件属组用户和其他人。其中，root不属于其他人，root对整个系统拥有绝对控制权。

文件所有者一般是文件创建者，当文件创建时创建者自动成为文件所有者，其中文件所有权可以转让，转让操作必须由root用户来执行。

也可以把文件交给一个组，这个组就是文件的属组。组是一群用户组成的一个集合。一般来说，文件被创建时，创建者自动成为文件的属主，创建者所在的组自动成为文件的属组。

最后是其他用户，一般来说其他用户的权限最低或者干脆没有权限。

#### 6.5.2 需要设置哪些权限

可以赋予某类用户对文件和目录享有3种权限：读取（r），写入（w）和执行（x）。

拥有读取权限意味着可以打开并查看文件的内容，写入权限控制着对文件的修改权限。

而是否能够删除和重命名一个文件则是由其父目录的权限设置所控制的。

要让一个文件可执行，必须赋予对文件的执行权限，执行权限分为两种，一种是可以直接由CPU执行的二进制代码，另一类是Shell脚本程序。

对目录而言，所谓的执行权限实际控制了用户能够进入该目录；而读取权限则负责确定能否列出该目录中的内容。；写入权限控制着在目录创建，删除和重命名文件。因此，目录的执行权限是其最基本的权限。

#### 6.5.3 查看文件和目录的属性

使用带选项-l的ls命令可以查看一个文件的属性，包括权限。例如：

```shell
ls -l /bin/login
-rwxr-xr-x 1 root root 57104 5月 28 14:37 /bin/login
```

第一个字段‘-’表示该文件是一个普通文件

rwxr-xr-x表示三组权限，断开应该为rwx，r-x，r-x，分别表示属主，属组和其他人拥有的权限。r表示可读取，w表示可写，x表示可执行。

第二个字段1表示该文件的链接数目。这里的1指的是该文件只有一个硬链接。

第三个和第四个字段表示该文件的属主以及属组，这里表示该文件的属主和属组都是root。

最后的字段分别表示文件大小（57104字节），最后的修改日期和时间（5月 28 14:37），以及这个文件的完整路径（/bin/login）。

如果要查看目录的属性，可以用-ld选项：

```shell
ls -ld /etc/
drwxr-xr-x 129 root root 12288 8月 20 22:40 /etc/
```

第一个字段中“d”表示该文件是一个目录

不带文件名作为参数的ls -l 命令列出当前目录下所有文件（不包括隐藏文件）的属性。

```shell
wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ls -l
总用量 48
-rwxrwxrwx 1 root root 10122 7月 22 05:58 时间安排表.odt
-rwxrwxrwx 1 root root 36124 8月 21 22:54 Linux从入门到精通概要笔记.odt
```

#### 6.5.4 改变文件所有权：chown和chgrp

chown命令用于改变文件的所有权。chown的基本语法如下：

```shell
chown [OPTION] … [OWNER] [:[Group]] FILE…
```

这条命令将文件FILE的属主改为OWNER，属组改为Group。

下面这个命令将文件days的属主更改为lew，将其属组更改为root

```shell
sudo chown lew:root days
```

如果只需要改变文件的属主，那么可以省略参数“：Group”，下面这条命令把days文件的属主更改为guest用户，对其属组不做更改。

```shell
sudo chown guest days
```

相应的，也可以只改变文件的属组，不对其属主进行更改。下列将文件days的属组更改为nogroup，对其属主不做更改：

```shell
sudo chown :nogroup days
```

chown提供了-R选项，用于改变一个目录以及其目录下所有文件（和子目录）的所有权。下面这条命令将iso/目录及其目录下所有文件的属主更改为lew：

```shell
sudo chown -R lew iso/
```

Linux单独提供了另一个命令chgrp用于设置文件的属组，下列中将文件days的属组更改为nogroup:

```shell
sudo chgrp nogroup days
```

与chwon命令一样，chgrp命令也可以使用-R选项，用于对子目录以及文件递归进行文件属组的更改，下列将ios目录及其目录下的文件和子目录的属组更改为nogroup：

```shell
sudo chgrp -R nogroup iso/
```

chgrp只实现了chown功能的一部分，在日常使用中仅凭个人使用习惯。

#### 6.5.5 改变文件权限：chmod

chmod用于修改一个文件的权限，一般采用“用户组+/-权限”的表述方式来增加/删除相应的权限。

具体来说，用户组包括了文件属主（u）,文件属组（g）,其他人（o）和所有人（a）。

而权限则包括了读取（r）,写入（w）和执行（x）。

下列命令增加了属主对文件days的执行权限：

```shell
chmod u+x days
```

chmod可以使用a同时指定3种人，下列命令删除除root用户外的所有用户（属主，属组和其他用户）对文件days的执行权限：

```shell
chmod a-x days
```

还可以通过“用户组=权限”的规则直接设置文件权限，同样对于文件days，下列命令赋予属主与属组的读取写入权限，而仅赋予其他用户的读取权限：

```shell
chmod ug=rw,o=r days
```

最后一条常用规则是“用户组1 = 用户组2”，用于将用户组1的权限和用户组2的权限设为完全相同。应用与文件days中，下面这条命令将其他人的权限设置为和属主的权限一样：

```shell
chmod o=u days
```

#### 6.5.6 文件权限的八进制表示

表6.2 八进制、二进制、文件权限之间的对于关系

| 八进制 | 二进制 | 权限 | 八进制 | 二进制 | 权限 |
| ------ | ------ | ---- | ------ | ------ | ---- |
| 0      | 000    | ---  | 5      | 101    | r-x  |
| 1      | 001    | --x  | 6      | 110    | rw-  |
| 2      | 010    | -w-  | 7      | 111    | rwx  |
| 3      | 011    | -wx  |        |        |      |
| 4      | 100    | r--  |        |        |      |

下列命令将文件prog的所有权赋予属主，而组用户和其他人仅有执行权限：

```shell
chmod 711 prog
```

### 6.6 文件类型

#### 6.6.1 查看文件类型

Linux中的一切都被表示成文件形式，包括程序进程，硬件设备，通信通道甚至是内核数据结构等。Linux中一共有7种文件类型。

使用带-l选项的ls命令可以查看文件类型。

```shell
wangyan@wangyan-ROG-Strix-G531GU-S5DU:/$ ls -l
总用量 924732
lrwxrwxrwx  1 root root     7 7月 18 07:17 bin -> usr/bin
drwxr-xr-x  5 root root   4096 7月 21 05:27 boot
drwxrwxr-x  2 root root   4096 7月 18 07:17 cdrom
```

以上述为例，第一个字段中的第一位表示文件类型:

表6.3 Linux中的文件系统

| 文件类型     | 符号 | 文件类型     | 符号 |
| ------------ | ---- | ------------ | ---- |
| 普通文件     | -    | 本地域套接口 | s    |
| 目录         | d    | 有名管道     | P    |
| 字符设备文件 | c    | 符号链接     | l    |
| 块设备文件   | b    |              |      |

Linux中有两类设备文件：字符设备文件和块设备文件。字符设备文件是指能够能够从它那里读取成字符序列的设备，如磁带和串行线路。块设备指的是能够

#### 6.6.2 建立链接：ln

符号链接也被称作软连接，需要使用带-s参数的ln命令来创建。下面这条命令给目标文件TARGET取一个别名LINK_NAME:

```shell
ln -s TARGET LINK_NAME
```

下面这个例子说明了符号连接的作用：

```shell
wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ls

时间安排表.odt days Linux从入门到精通概要笔记.odt

wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ln -s days my_days

wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ls

时间安排表.odt days Linux从入门到精通概要笔记.odt my_days

wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ls -l my_days

lrwxrwxrwx 1 root root 4 8月 22 11:50 my_days -> days


```

从my_days可以看到，文件被指向days，从此访问my_days 就相当于访问 days。my_days 就相当于days的一个别名，因此删除my_days 并不会影响days，但是如果days被删除了，那么my_days 就没有意义了。

符号链接还可用于目录，下面这条命令建立了一个指向/mnt/sda/的符号链接mnt_sda:

```shell
wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ln -s /mnt/sda/ mnt_sda

wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ ls -l mnt_sda

lrwxrwxrwx 1 root root 9 8月 22 11:55 mnt_sda -> /mnt/sda/

wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$


```

Linux中还有一种被称为“硬链接”，这种链接用于将两个独立的文件联系到一起。

硬链接与符号链接不同的是，硬链接是直接引用，而符号链接是通过名称进行引用。使用不带选项的ln命令建立硬链接:

```shell
ln days my_days
```

上面这条命令建立了一个链接到days的新文件hard_days,这是两个独立的文件，只是被联系到了一起。

这两个文件具有相同的内容，其中一个的内容如果改变另一个也会跟着改变。

### 6.7 输入输出重定向和管道

#### 6.7.1 输出重定向

重定向和管道是Shell的高级特性，该特性允许用户认为的改变程序获取输入和产生输出的位置。几乎所有的操作系统都支持此类操作。

程序在默认情况下输出结果的地方被称为标准输出（stdout）。通常来说，标准输出一般指向显示器。例如利用ls命令获取当前目录下的文件列表，并将其输出到标准输出，然后用户在屏幕上看到这些文件名。

输出重定向用于把程序的输出转移到另一个地方去，下列中的命令将ls的输出重定向到lsout文件中：

```shell
ls > ~/lsout
```

这样程序就不会在屏幕中显示出来，而是会出现在用户主目录下的lsout文件中。

如果lsout文件不存在，输出重定向符号“>”会试图建立这个文件。如果该文件已经存在，那么“>”会删除原有文件，用新内容替代。如果要保留原来文件中的内容，可以使用输出重定向符号“>>”:

```shell
uname -r >> data_out
```

#### 6.7.2 输入重定向

和标准输出类似，程序默认情况下接受输入的地方被称为标准输入（stdin）。通常来说，标准输入一般指向键盘。

如果使用不带任何参数的cat命令，那么cat会停在那里，等待从标准输入（也就是键盘）获取数据。

用户的每一行输入会立即显示在屏幕上，直到使用Ctrl+D快捷键提供给cat命令一个文件结束符。

通过使用输入重定向符号“<”可以让程序从一个文件中获取输入:

```shell
cat < days
```

上面这条命令将文件days作为输入传递给cat命令，cat读取days中每一行，然后输出读取到的内容，当遇到文件结束符时，就停止读取操作。

cat命令可以通过接受一个参数来显示文件内容，因此“cat < days”完全可以用cat days 替代。

事实上，大部分命令都能够以参数的形式在命令行上指定输入的文件名，因此，输入重定向并不经常使用。

另一种输入重定向的例子被称为立即文档（here document）。这种方式使用操作符“<<”。立即文档明确告诉Shell从键盘接受输入，并传递给程序。

```shell
wangyan@wangyan-ROG-Strix-G531GU-S5DU:/mnt/sda/Linux_Files/Study_Files$ cat << EOF
\> Hello
\> nihao
\> EOF
Hello
nihao
```

cat命令从键盘接受两行输入，并将其送往标准输出。立即文档指定了一个代表结束的分隔符（在这里是单词EOF）。Shell遇到这个单词的时候，即认为输入结束，并把刚才的键盘输入一起传递给命令。

用户可以随意指定单词作为立即文档的分隔符，像EOF，END，eof等均可，只要确保它不是正文的一部分。

输入重定向与输出重定向是可以结合使用的，例如下面命令：

```shell
cat << END >hello
```

这条命令首先让cat命令以立即文档的方式获取输入，然后再把cat的输出重定向到hello文件。

#### 6.7.3 管道：|

管道将重定向再向前推进了一步。通过一根竖线“|”，将一条命令的输出连接到另一条命令的输入。下列命令显示了任何在文件列表中查找文件名包含某个特定字符串的文件：

```shell
ls | grep ay
```

ls首先列出当前目录下的所有文件名，管道|“|”接受到这些输出，并把它们发送给grep命令作为其输入。最后grep命令在这堆文件中匹配含有ay字符串的文件，并在标准输出（显示器）显示。

# 第七章 软件包管理

### 7.1 快速上手：安装和卸载Chrome for Linux

#### 7.1.1 安装Chrome for Linux

目前Linux下的Google Chrome浏览器有两个版本，Beta（测试版）和Unstable（不稳定版）。对于Debian和Unbuntu用户，下载Chrome浏览器可以输入以下命令：

```shell
sudo dpkg -i google-chrome-stable_current_i386.deb
```

对于openSUSE和其他使用RPM软件包的用户，则可输入如下命令：

```shell
rpm -i vh google-chrome-stable_current_i386.rpm
```

如果系统没有报错的话，一般都是正常安装完毕的。

#### 7.1.2 运行Chrome for Linux

单击“应用程序”|“互联网”|GoogleChrome按钮，就能正常运行。

或者打开终端，在命令行中输入：

```shell
google-chrome-stable
```

#### 7.1.3 卸载Chrome for Linux

当前版本的Chrome for Linux仍然存在很多不足。下面介绍如何卸载Chrome for Linux。

一般来说，卸载软件需要提供完整的软件名和版本信息（事实上很少人会记住他们），软件包管理工具可以帮助用户管理这些信息。

Debian和Ubuntu用户使用下面的命令：

```shell
dpkg -l | grep chrome
```

Red Hat和其他使用RPM软件包的用户可以使用下面的命令：

```shell
rpm –query chrome
```

用以上方法就能够找到相关软件包完整的名字了，接下来可以着手卸载了，命令如下：

```shell
sudo dpkg -r google-chrome-stable
```

Red Hat和其他使用RPM软件包的用户可以使用下面的命令：

```shell
rpm -e google-chrome-stable
```

如果没有报错，系统奖会完整的将相关软件卸载。

### 7.2 软件包管理系统简述

在早期的UNIX/Linux系统中，安装软件需要从源代码开始编译软件，并为系统作出各种调整，甚至需要修改部分源代码。

针对这种细节且需要耗费巨大精力的工作，软件包的概念应运而生：软件包管理系统的应用令Linux管理员从无休止的兼容性问题中解脱出来，使得安装软件成为一种事实上的原子操作。

当然，使用软件包安装软件同样需要考虑到依赖性的问题。只有软件所依赖的所有库和支持都正确安装完成，软件才能被顺利安装。有些高级软件包管理工具，例如APT和yum可以自动搜寻依赖关系并执行安装。

常见的软件包格式有两种：RPM即Red Hat Package Manager（Red Hat软件包管理器），最初是由Red Hat公司开发，现已经被大多数Linux版本所应用；另一种则是Debian和Ubuntu上使用的.deb格式。两种版本的功能类似。

如今绝大部分Linux版本都使用高级软件包管理工具来进一步简化软件包安装的过程。通常的免费版本有RPM和yum（其中yum只能用于RPM）。除此之外，一些主要的Linux开发商也会开发用于自己发行版的高级包管理工具，例如Red Hat 的Red Hat Network和SUSE 的ZENworks。

一般高级软件包管理系统基于这样几个理念和目标：

简化定位和下载软件包的过程

自动进行系统更新和升级

方便管理软件包件的依赖关系。

### 7.3 管理.deb软件包：dpkg

#### 7.3.1 安装软件包

dpkg软件包管理工具主要应用于Debian和Ubuntu版本，详细选项和功能可以通过dpkg –help获取完整帮助信息。

dpkg使用 –install选项安装软件，这个选项可以简写成-i。事实上，Linux中很多命令都存在这类缩写形式。

所有安装包在安装前必须确保其所依赖的库和支持都已经安装在系统中。虽然也可以使用--force-来强制安装，但该情况一般只针对软件安装影响比较小的情况下，除非迫不得已，一般情况下不建议使用--force-选项。

#### 7.3.2 查看已安装的软件包

假设当前需要查看系统中OpenSSH版本信息时，可以使用如下命令：

```shell
dpkg -l | grep openssh
```

对于系统管理员而言，常常需要知道所安装的软de件究竟向系统复制了哪些文件，因此可以使用dpkg提供的—search选项（简写为-S）。仍以上文OpenSSH为例：

```shell
dpkg -S openssh
```

#### 7.3.3 卸载软件包

使用dpkg提供的—remove（简写为-r）选项可以方便的卸载已经安装的软件包。下面以卸载Open浏览器为例：

```shell
dpkg -l | grep opera       #查看安装包名
sudo dpkg –remove opera  #卸载浏览器
```

### 7.4 管理RPM软件包：rpm

#### 7.4.1 安装软件包

rmp工具适用于管理.rpm格式的软件包，适用于绝大部分Linux版本。rpm更多的高级功能可以参考用户手册。

使用rpm -i命令安装一个软件包，一般情况下只需要选项-i就足够了，人们通常习惯加上 – v和-h选项，-v用于显示rpm当前正在执行的工作，-h选项通过打印一系列的“#”提醒用户当前的安装进度。例如:

```shell
sudo rpm -i -v -h dump-0.4b41-1.src.rpm
```

可以将多个选项合并在一起，从而省略前面的短线“-”。下面的两条命令是等价的：

```shell
sudo rpm -i -v -h dump-0.4b41-1.src.rpm

sudo rpm -ivh dump-0.4b41-1.src.rpm


```

rpm同样提供了—force选项，用于忽略一切依赖兼容问题，强行安装软件包。

另外，正在安装软件包需要在其他一些软件包支持下才能正常工作时，就会发生软件包相关性冲突。利用--nodeps选项可以时RPM忽略这些错误继续安装软件包，这种方法同上述一样，一般不建议使用。

#### 7.4.2 升级软件包

rpm -U命令用于升级一个软件包。使用方法同rpm -i类似，用户也可以通过-v和-h选项来指导安装。下列命令将已安装的旧版软件更新为新版软件：

```shell
sudo rpm -Uvh [新版软件包名]
```

升级实际上是卸载和安装的组合使用。RPM先卸载旧版软件，然后再安装新版软件。RPM在升级过程中会保留软件的配置文件，以避免用户运行环境发生变化。

#### 7.4.3 查看已安装的软件包

使用rpm -q 命令可以查询当前系统已经安装的软件包。用户应该指定软件包的名字（而不是安装软件的名字），则RPM会列出其具体的版本信息：

```shell
rpm -q [软件名]
```

在很多情况下，用户可能不记得软件包的完整名称，给命令“rpm -q”命令加上-a选项则可以列出当前系统上已经安装的所有软件包：

```shell
rpm -qa
```

结合管道和grep命令可以找到自己想要的软件包：

```shell
rpm -qa | grep [name]
```

#### 7.4.4 卸载软件包

使用rpm -e命令可以卸载软件包，该命令接受软件包的名字作为参数，下面这条命令从系统中删除了软件包tcpdump:

```shell
rpm -e tcpdump
```

有些时候卸载软件会出现一些问题，由于软件包之间存在依赖关系，很可能会出现某个软件无法运行的情况。

当需要卸载的软件包之间存在依赖时，RPM会谨慎拒绝卸载请求，用户也可以使用—noddps命令忽略，一般情况下不建议使用该命令。

此外RPM还提供了—test选项，该选项会通过RPM模拟卸载过程，但是并不会真的执行删除操作。下面对某个软件包执行带有--test 选项的卸载命令（选项-vv是两个v，而不是w）：

```shell
sudo rpm -e -vv –test [name]
```

### 7.5 高级软件包工具：APT

#### 7.5.1 APT简介

rmp和dpkg软件包管理工具虽然能够有效减少安装软件的工作量，但是无法有效解决软件之间的依赖关系，因此，APT应运而生。

APT全称为Advance Package Tool（高级软件包工具）。这是迄今最成熟的软件包管理系统。它可以自动检测软件依赖问题，下载和安装所有文件；甚至只需要一条命令就可以更新系统上的所有软件包。

最初APT被设计运行于Debian系统上，如见已经被移植到使用RPM软甲包发行版上。

APT工具最常使用的两个命令：apt-get和apt-cache。前者用于执行和软件包安装有关的所有操作；后者主要用于查找软件包的相关信息。大部分情况下，用户也可以使用图形化的APT工具。

#### 7.5.2 下载和安装软件包

系统第一次启动时需要运行apt-get update更新当前apt-get缓存中的软件包信息。

然后就可以使用apt-get install 命令安装软件包了。以安装战棋类游戏Wesnoth为例：

```shell
sudo apt-get uptate

sudo apt-get wesnoth


```

APT提供了大量信息，并自动解决了包的依赖问题。apt-get还有其他一些命令，如下表所示：

表7.1 apt-get的常用命令

| 命令            | 描述                                       |
| --------------- | ------------------------------------------ |
| Apt-get install | 下载并安装软件包                           |
| Apt-get update  | 下载并安装在本系统上已有的软件包的最新版本 |
| Apt-get remove  | 卸载特定的软件包                           |
| Apt-get source  | 下载特定的软件源代码                       |
| Apt-get clean   | 删除所有已下载的包文件                     |

 

下列命令用于删除软件包tremulous：

```shell
sudo apt-get remove tremulous
```

使用apt-get -h 可以列出apt-get的完整用法。

#### 7.5.3 查询软件包信息

同rpm和dpkg一样，使用apt-get安装和卸载软件时必须提供软件包的名字。可以使用APT提供的工具apt-cache来完成包名的查询。

apt-cache search命令可以搜索软件包列表中特定的软件包。下例中命令用于查找一个软件包的包名：

```shell
apt-cache search [name]
```

apt-cache将按照字母顺序搜寻列出一切包含[name]字样的软件包，用户可以凭借记忆和经验判断自己要找的软件包。

另一个常用的apt-cache命令是apt-cache depends，用于列出特定软件包的依赖关系，例如想要查看某个软件包[name]需要依赖些些什么，可以使用下面的命令：

```shell
apt-cache depends [name]
```

APT系统显示出来的依赖关系并不需要用用户手工解决，全部由系统自行完成。

#### 7.5.4 配置apt-get

apt-get 用于下载软件的地址均放在/etc/apt/sources.list中。

![img](file:///C:/Users/98763/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

上图中的某些字段解释如下：

deb和deb-src：软件包的类型。其中src表示源代码

URL：表示指向CD-ROM，HTTP或者FTP服务器的地址，表示获取软件包的地址。

hardy等：表示软件包的发行版本和分类，用于帮助apt-get遍历软件库。

以“#”开头的表示注释

#### 7.5.5 使用图形化的APT

Linux发行商也开发了APT的图形化界面，对于新用户会更加友好。可以使用Ubuntu附带的“新立得软件包管理器”工具的使用和配置。

系统默认并没有安装，需要用户自行安装。具体工具使用并不复杂，在此省略。

### 7.6 进阶：从源代码编译软件—以MPlayer为例

#### 7.6.1 为什么要从源代码编译

从源代码编译软件的流程是多种多样的，但是大致思维都差不多。

尽管Linux提供的高级软件包管理工具基本能够完美解决Linux软件安装问题，但是最原始的方法—从源代码编译，还是有必要了解与掌握的。

有时候软件开发商并没有提供二进制的软件包或者只提供了特定版本的软件包，就只能从源代码编译安装软件。

处于企业和个人的特殊需求，需要对源代码进行修改，则经过修改的软件必须重新编译。

能够让编译者获取更多的控制。

#### 7.6.2 下载和解压软件包

Mplayer是一款支持格式十分全面的多媒体播放软件，对于Linux，Windows以及Mac OS等操作系统均能够支持。可以从www.mplayerhq.hu/design7/dload.html下载最新版本。

在Linux系统中，“.tar.bz2”和“.tar.gz”这样的压缩格式是发布源代码的标准格式。下面命令用于解压这两种压缩包：

```shell
tar zxvf Mplayerr-1.1.tar.gz    #解压缩Mplayerr-1.1.tar.gz
tar jxvf Blue-1.8.tar.bz2       #解压缩tar jxvf Blue-1.8.tar.bz2
```

解压后得到两个目录Mplayerr-1.1和 Blue，其中Mplayerr-1.1是Mplayer的源代码， Blue Skin是Mplayer的皮肤。

#### 7.6.3 正确配置软件

Linux中所有软件都使用configure这个脚本来配置以源代码形式发布的软件。configure依据用户提供相关参数生成对应的makefile文件，该文件用于指导make命令正确地编译源代码。

几乎所有的configure脚本都提供了—prefix这个选项，用于指定软件安装的位置。如果用户不指定，系统就会按照其默认位置进行安装。下面这条命令将软件安装在/usr/local/games/foobillard目录下：

```shell
./configure –prefix=/usr/local/games/foodillard
```

不同的软件对configure提供了其他不同的选项，这里不好一一列举。另外例如HTTP服务器一般不会用到图形界面，但是Mplayer需要。所以在拿到软件的源代码后，需要借助软件的安装文档来辅助安装，一般这类文档都叫做README或者INSTALL。以安装Mplayer为例：

```shell
cd Mplayer-1.1/       #进入Mplayer的源代码目录
cat README        #查看安装文档
```

在安装文档中Mplayer的configure脚本提供了—enable-gui 这个选项配置启动图形界面。下面这个命令启用Mplayer的图形界面，并将Mplayer安装在其默认路径中：

```shell
./configure –enable-gui    #执行configure脚本
```

configure脚本首先检查当前系统是否符合编译条件。一般需要安装正确的编译器，Linux中通常是gcc，并且系统的体系结构应该和该软件的设计一致。如果通过检查，则接下来就可以着手编译软件了。

#### 7.6.4 编译源代码

在上条命令执行之后，configure会提示用户接下来应该做什么：

‘make’ will now compile Mplayer and ‘make install’ will install it.

```shell
make    #编译源代码
```

make是一种高级编译工具，它可以依据makefile文件中的规则调用合适的编译器编译源代码。大型软件的模块之间是错综复杂的，不可能逐一手动编译。使用make工具可以按照预先设定的步骤（这一步一般是由configuure脚本完成）自动执行所有这一切。

#### 7.6.5 安装软件到硬盘

编译完源代码之后，应该运行make install 命令来安装软件。由于需要复制某些文件进入一些系统目录中去，所以此处需要root权限：

```shell
sudo make install     #以root身份安装软件
```

或者用下面这套命令也可以：

```shell
su root
make install
```

至此，Mplayer主程序就完成了，然后在帮助文档中找到关于GUI的安装信息，即下载的皮肤文件安装信息。按照文档指示进一步操作。

#### 7.6.6 出错了怎么办

安装完成后可以尝试启动程序：

```shell
gmplayer &      #以图形方式启动Mplayer
```

在这个过程中很有可能会出错，事实上从源代码编译软件的出错率是相当大的，就算是Linux高级用户有时候也不能保证一次成功。例如安装失败后显示如下：

```shell
New_Face failed. Maybe the font path is wrong.
Please supply the text font file(~/.mplayer/subfont.ttf).
Subtitle font：load_sub_face failed.
```

从以上信息可以了解字体文件出了问题，接下来按照README文件这指示，从系统中选择一个ttf字体文件，并且复制为“~/.mplayer/subfont.ttf”

大多时候出现的问题并不像上述一样简单，需要仔细分析出错信息，再看看他人有没有出现过类似错误，一步步解决问题。

# 第八章 磁盘管理

8.1 关于硬盘

硬盘是当前使用最为广泛的数据存储设备。内部是数个重叠在一起的数据盘片，读取数据时，盘片以恒定的速度转动，旁边的磁头进行读和写。

现如今有多种不同的硬盘接口，SCSI和IDE曾经占据统治地位，现如今越来越多的人选择了SATA硬盘，也就是所说的串口硬盘。

8.2 Linux文件系统

8.2.1 ext3fs和ext4fs文件系统

操作系统必须使用一种特定的方式对硬盘进行读写，这种对物理空间的组织方式就是文件系统，通常在格式化硬盘时创建。

在过去很长一段时间，ext3fs(Second Extended File System)是Linux上主流的文件系统。随着ext4fs（Third Extended File System）出现，ext3fs逐渐被取代。与ext3fs相比，extfs增加了日志功能，大大提高了文件系统的可靠性。

8.2.2 ReiserFs文件系统

ReiserFs是另外一种在Linux上广泛使用的文件系统。其作者Hans Reiser在1997年7月23日公布。Linux内核从2.4开始支持ReiserFs。这种文件系统曾经一度默认是SUSE Linux的默认文件系统。

作为一种日志文件系统，ReiserFS还加入了模块化的文件系统接口，它可以增加系统在特殊环境里的安全性，对于开发人员和系统管理员比较有用。

8.2.3 有关swap

事实上，swap不是一种文件系统，而是交换分区，当内存不够用时，操作系统就会从外存中取一块暂时不用的空间，用于放置内存数据，该空间可以理解为虚拟内存。

8.3 挂载文件系统

8.3.1 快速上手：使用光盘

Linux现在的发行版都能够自动识别光盘，从试验出发，这里手动对光盘进行挂载：

打开终端，输入命令：

sudo mkdir /mnt/cdrom               #新建一个目录

sudo mount /dev/cdrom /mnt/cdrom   #挂载光盘至这个新建的目录

mount：块设备 /dev/scd0 写保护，以只读方式挂载

接下来可以通过访问/mnt/cdrom来访问光盘：

cd /mnt/cdrom    #进入挂载目录

ls              #查看

使用完成后，卸载：

cd /                    #退出挂载目录

sudo umount /dev/cdrom   #卸载光盘

8.3.2 Linux下设备的表示方法

Linux下的设备都被当成文件来操作，在Linux环境下，每个设备都被映射成一个特殊文件，即“设备文件”。对上层而言，所有对设备的操作都是通过读写这个文件来实现的。Linux中的所有的设备文件都在/dev目录下。

其中大部分时块设备和字符设备，块设备比如硬盘，磁盘可以随意读写，/dev/hda1、/dev/sda2等就是典型的块设备文件；而字符设备只能按顺序接受“字符流”，常见的有打印机等。

硬盘在Linux系统中遵循着一定的命名规则，如sd1表示第1块硬盘上的第一个主分区，sdb2表示第二块硬盘上的第2个主分区。用户不能直接通过设备文件访问存储设备，所有存储设备都需要先挂载到某个目录下才能被访问。

8.3.3 挂载文件系统：mount命令

通过mount命令可以挂载文件系统，大部分情况下需要以root身份执行。也可以使用-t选项明确指明设备所使用的文件系统类型。如下所示：

 表8.1 常用文件系统的表示方法

| 表示方法 | 描述                         |
| -------- | ---------------------------- |
| Ext2     | Linux的ext2文件系统          |
| Ext3     | Linux的ext3文件系统          |
| Ext4     | Linux的ext4文件系统          |
| Vfat     | Windows的FAT16/FAT32文件系统 |
| Ntfs     | Windows的NTFS文件系统        |
| Iso9660  | CD-ROM光盘的标准文件系统     |

在不指明类型的情况下，mount会自动检测设备上的文件系统，并以相应的类型进行挂载，因此，大部分的情况下，-t选项不是必要的。

另外两个选项是-r和-w，分别指定以只读模式和可读写模式挂载设备。其总，-w选项是默认值。

8.3.4 在启动的时候挂载文件系统：/etc/fstab文件

该配置文件对于所有用户可读，但只有root用户有权修改文件。以下命令：

cd /etc/   #进入etc目录

cat fstab  #查看fstab配置文件

![img](file:///C:/Users/98763/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)fatab表中各个纵列依次表示如下含义：

用来挂每个文件系统的UUID（用于指代设备名）

挂载点

文件系统的类型

各种挂载参数

备份频度

在重启动过程中文件系统的检查顺序。

需要注意的是：Ubuntu中使用设备的UUID来作为设备的唯一标识，而openSUSE中以直接路径来作为设备的标识。

表8.2 挂载设备的常用参数

| 参数            | 含义               |
| --------------- | ------------------ |
| Auto            | 开机自动挂载       |
| default，noauto | 开机不自动挂载     |
| Nouser          | 只有root可挂载     |
| Ro              | 只读挂载           |
| Rw              | 可读可写挂载       |
| User            | 任何用户都可以挂载 |

8.3.5 为什么无法弹出光盘：卸载文件系统

在光盘被安全卸载之前，作为一款注重安全性的操作系统，Linxu不允许光盘能被直接弹出这样不负责的事情出现。

Umount用于卸载文件系统，后面只需要跟上设备名，可能会用到参数-r，这个参数在无法卸载文件系统的情况下，重新以只读方式重新载入：

sudo umount -r /dev/sda1

文件系统只有在不被使用的情况下才可以被卸载。

8.4 查看磁盘使用情况：df

df命令会搜集和整理当前已经挂载的全部文件系统的一些重要的统计数据，使用也比较方便。

![img](file:///C:/Users/98763/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif)df命令显示的信息十分完整。包括挂载的设备名以及挂载点，df命令还会显示当前磁盘的使用情况。

除此之外，df还提供了-t参数用于显示特定的文件系统。

![img](file:///C:/Users/98763/AppData/Local/Temp/msohtmlclip1/01/clip_image008.gif)

上述命令只能显示已经挂载的特定文件系统的信息。

8.5 检查和修复文件系统：fsck

文件系统在系统发生异常时可能会产生不一致，对于小的损坏，可以使用fsck命令来进行检查修复。fsck会进行检查，将日志回滚到上一次正常状态中。fsck接受分区编号来指定需要检查的文件系统。

带有-p选项的fsck命令会读取fstab文件来确定检查哪些文件系统，并通过每条记录最后一个字段所指定的顺序，对文件系统按照数字的升序进行检查：

sudo fsck -p

8.6 在磁盘上建立文件系统：mkfs

所有磁盘在使用前必须进行格式化，Linux环境下，mkfs命令用于完成这一操作。

mkf本身并不执行建立文件系统的工作，而是调用相关程序，其中包括mkdosfs、mke2fs、mkfs.minix等。

使用-t参数指定文件系统。

表8.3 常用的文件系统

| 文件系统 | 描述                      |
| -------- | ------------------------- |
| Minix    | Linux最早期使用的文件系统 |
| Ext3     | ext3文件系统              |
| Ext4     | ext4文件系统              |
| Msdos    | FAT文件系统               |

下面命令将第二块硬盘的第一个分区(sdb1)格式化为ext4格式：

sudo mkfs -t /dev/sdb1

另外也可以使用-c选项来检查指定设备上损坏的块：

sudo mkfs -t ext4 -c

如果硬盘已经挂载到文件系统上，那么需要先使用umount进行卸载。

8.7 使用USB设备

“软驱”已经完全被USB设备取代，其中这些USB设备包括U盘，MP3，iPod，移动硬盘，数码相机等。Linux对这些提供了非常好的支持，一般情况下，USB会自动挂载接入USB接口的设备。

对于某些系统没有识别的设备，可是手动进行挂载。USB设备在Linux系统中被认定为SCSI设备，因此可以从/dev/sd[a-z][1...]进行挂载。

如果系统中的硬盘是IDE接口的话，那么USB设备被识别为第一块SCSI设备，即sda；如果系统中有一块SCSI硬盘的话，那么USB设备会被识别为第二块SCSI设备，即sdb；总之，Linux会将USB设备识别为第一个没有被硬盘占用的SCSI设备。

挂载与卸载USB设备示例：

sudo mount */dev/sdb1 /mnt/usb/*

*sudo umount /dev/sdb1*

另外，还可以使用lsusb命令可以列出当前内核已经发现的usb设备*。*

8.8 压缩工具

8.8.1 压缩文件：gzip

gzip是Linux下使用非常广泛的压缩工具，只要简单的在gzip命令后跟上一个想要压缩的文件作为参数就可以了。例如：

gzip linux_book_bak.tar

在默认情况下，gzip命令会给压缩的文件加上一个“gz”扩展名。处理过后，linux_book_bak.tar就会变成linux_book_bak.tar.gz。

要解压所.gz文件，就可以使用gunzip命令或者带-d选项的gzip命令。例如：

gunzip linux_book_bak.tar.gz

或者

gzip -d linux_book_bak.tar.gz

应该保证需要解压的文件有合适的扩展名。gzip(gunzip)支持的扩展名有.gz，.Z,-gz,.z,-z和z。

gzip提供了-l查看压缩效果。例如：

gzip -l linux_book_bak.tar.gz

最后，gzip命令的-t选项可以用来测试压缩文件的完整性。如果正常则不会给出任何显示，系统提供了-tv选项来显示压缩完整，例如：

gzip -tv linux_book_bak.tar.gz

8.8.2 更高的压缩率：bzip2

bzip2可以提供比gzip更高的压缩率。该命令使用方法基本与gzip一致，例如压缩与解压过程的命令分别为：

bzip2 [filename].tar    #压缩文件

bunzip2 [filename].tar.bz2  #解压文件

或者

bzip2 -d [filename].tar.bz2  #解压文件

同样可以使用-tv选项检查压缩文件的完整性：

bzip2 -tv [filename].tar.bz2

8.8.3 支持rar格式

rar俨然已经成为取代zip成为Windows下的标准压缩格式。在Linux下处理rar文件可以使用RAR for linux。

要解压一个文件，仅需使用命令rar和选项x，例如：

rar x music.rar

8.9 存档工具

8.9.1 文件打包：tar

Linux中最著名的打包工具是tar，该程序读取多个程序和目录，并将他们打成一个包。下面命令将shell目录以及其下文件打成一个包：

tar -cvf shell.tar shell/

上述用到了tar命令的三个选项，c用于指导tar创建归档文件，v用于显示命令的执行过程，f则用于指定归档文件的文件名，本例中把它设置为“shell.tar”。最后一个（或几个）参数指定了需要打包的文件和目录（这里指的是shell目录）。和gzip不同的是，tar不会删除原来的文件。

要解开.tar文件，则需要-x选项，命令如下：

tar -xvf shell.tar

tar命令提供了-w选项，用于每次将单个文件加入（或者抽出）归档文件时征求用户的意见。用y或n回复：

tar -cvwf shell.tar shell/

解开tar文件时也遵循相同的-w选项：

tar -xvwf shell.tar

tar命令另一个非常有用的选项是-z，使用了这个选项的tar命令会自动调用gzip程序完成相关操作。创建归档文件时，tar程序最后调用gzip压缩归档文件；解开归档文件时，tar程序先调用gzip解压缩，然后再解开被gzip处理过的.tar文件。下例tar命令将shell目录打包，并调用gzip程序处理打包后的文件：

tar -czvf shell.tar.gz shell/

这条命令相当于下面两条命令的组合:

tar -cvf shell.tar shell/

gzip shell.tar

类似的，下面命令先调用gunzip解压shell.tar.gz，然后再解开shell.tar（此处省略了-v选项）：

tar -xzf shell.tar.gz

这条命令相当于下面两条命令组合：

gunzip shell.tar.gz

tar -xf shell.tar

tar命令的-j参数用于调用bzip2程序，这个参数的用法同-z完全一致。下面这个例子用于解开shell.tar.bz2:

tar -xjf shel.tar.bz2

8.9.2 文件转移：dd

dd命令曾经广泛地用于复制文件系统，目前几乎被更好用的dump命令和restore命令取代，在一些追求简便的场合下，dd仍发挥着作用。

dd命令使用if选项指定输入端的文件系统，而of选项则指定其输出端，下面这条命令将一张完整的CD完整的转储为iso镜像文件：

dd if=/ dev/ cdrom of=CD.iso

dd也可以在两个大小完全相同的分区或是磁带之间复制文件系统。在面对某些非Linux系统上写入的磁带，dd命令很可能是唯一的选择。

8.10 进阶1：安装硬盘和分区—fdisk

8.10.1 使用fdisk建立分区表

Linux中用于建立分区表的工具叫做fdisk，该工具目前支持市面上几乎所有的分区类型。

假设本机已经已经安装了一块SCSI硬盘，再增加一块SCSI硬盘后，则第二块硬盘在系统中应该被识别为sdb。可以使用下列命令查看当前的SCSI硬盘内容：

ls / dev/ | grep sd  #查看目录/dev下带有sd开头的文件

下面将sdb建立3个分区，并且在第1个和第3个分区上建立ext3fs文件系统，把第2个分区留作swap交换分区。

在root身份下进行操作演示，首先启动fdisk程序，并且以目标设备（/dev/sdb/）作为参数：

fdisk /dev/sdb

fdisk是一个交互式应用程序，执行完上条命令后会显示提示信息，并给出冒号“：”等待用户输入，使用m命令可以显示fdisk所有可使用的命令缩写及其简要介绍，下表提供了本节用到的4个命令：

表8.4 本节用到的fdisk命令

| 命令全称 | 缩写形式 | 含义             |
| -------- | -------- | ---------------- |
| New      | N        | 创建一个新分区   |
| Print    | P        | 显示当前分区设置 |
| Type     | T        | 设置分区类型     |
| Write    | W        | 把分区表写入硬盘 |

只有在使用了write命令后，硬盘上的分区信息才会真正被改变。下面将硬盘sdb创建第一个分区，并将所有分区设置为主分区：

Command（m for help）：new     #设置为主分区

Command action
           e extended

​     p primary partition(1-4)

p                             #设置为主分区

Partition number(1-4):1           #设置为第一个主分区

First cylinder(1-652，default 1)：1 #分区从硬盘的第一个柱面开始

Last cylinder or +size or +sizeM or +sizeK(1-652,default 652):+2G    

​                              \#设置分区容量（2GB）

以print命令查看分区表：

Command(m for help)：print

下面设置第2个硬盘分区，这个分区用作swap交换，这里给它1GB容量：

Command（m for help）：new     #设置为主分区

Command action
           e extended

​     p primary partition(1-4)

p                             #设置为主分区

Partition number(1-4):2           #设置为第2个主分区

First cylinder(1-652，default 245)：245 #分区从硬盘的第一个柱面开始

Last cylinder or +size or +sizeM or +sizeK(245-652,default 652):+1G  

​                              \#设置分区容量（1GB）

接下来需要修改分区类型，而不是默认的Linux分区：

Command(m for help)：type      #修改分区类型

Partition number(1-4)：2         #设置需要修改的对象（2号分区）

Hex code(type L to list codes)：82  #设置为82号（swap）分区类型

系统分区类型号82是swap分区类型，可以按照提示使用命令L查看分区类型极其编号：

Hex code(type L to list codes)：L  

最后设置第三个分区，使用剩余所有硬盘空间：

Command（m for help）：new     #设置为主分区

Command action
           e extended

​     p primary partition(1-4)

p                             #设置为主分区

Partition number(1-4):3           #设置为第3个主分区

First cylinder(368-652，default 368)：  #直接回车使用默认值

Last cylinder or +size or +sizeM or +sizeK(368-652,default 652):    

​                              \#直接回车使用默认值

当设置好以上分区表时，使用write命令将分区信息写入硬盘：

Command（m for help）：write    #写入硬盘

至此，以上硬盘3个分区建立完成。

8.10.2 使用mkfs建立ext3fs文件系统

创建完分区后，就需要在各个分区上建立文件系统，需要使用mkfs命令：

mkfs -t ext4 /dev /sdb1    #在新硬盘第一个分区上建立ext3fs文件系统

8.10.3 使用fsck检查文件系统

使用fsck命令检查刚刚建立的文件系统，这一步并不是必要的，但是能在开始时发现问题，解决隐患。可以使用-f选项强制fsck检查新的文件系统：

fsck -f /dev/sdb1      #使用fsck强制检查新建立的文件系统。

8.10.4 测试分区

现在可以将新建立的文件系统挂载到相应的目录：

mkdir /web       #新建/web目录用于挂载文件系统

mount /dev/sdb1 /web/    #挂载sdb1至/web目录

df /web          #查看该文件系统的使用情况

8.10.5 创建并激活交换分区

交换分区需要使用mkswap来初始化，该命令以分区的设备名作为参数：

mkswap /dev/sdb2    #用mkswap初始化第2个分区

最后使用swapon命令检查并激活交换分区：

swapop /dev/sdb2

使用-s选项的swapon命令查看当前系统上已经存在的交换分区：

swapon -s    #列出系统上的交换分区及其使用情况

8.10.6 配置fstab文件

最后编辑fstab文件，可以在系统启动时加载这些文件系统。在/etc/fstab文件中加入以下几行命令：

[设备路径]   [挂载目录路径] 系统类型（ext3fs） defaults     0   2

以/dev/sdb1的配置为例：

指定将[设备路径/dev/sdb1]安装在[挂载目录路径/web]下；

文件系统类型是ext3fs；

按照默认选项安装；

按备份频度0执行备份（完整备份）；

fsck检查次序为2（序号为0的最先检查）。

8.10.7 重新启动系统

一切顺利的情况下，再次重新启动系统，文件系统和交换分区都应该根据fstab文件的设置被正确地挂载了。

如果某个文件系统出了问题，系统将不能正常启动，而是引导进入救援模式。在这种情况下，用户应该根据下面步骤手动解决问题：

1）提供Root口令，以root身份登陆系统；

2）使用fsck检查并试图修复受损的文件系统；

3）如果没有解决问题，可以使用mkfs重新在分区上建立文件系统；

4）如果依旧解决不了问题，可以需要使用fdisk重新建立分区表。

无论如何，用户都可以通过删除fstab文件中对应的配置行来临时解决系统无法启动的问题。

8.11 进阶2：高级硬盘管理—RAID和LVM

以下介绍Linux下两个高级硬盘管理工具RAID和LVM，这两个工具对于服务器尤其有用，一般用户很少有机会用到。

8.11.1 独立磁盘冗余阵列：RAID

RAID用于在多个硬盘上分散存储数据，并且能够“恰当”地存储重复数据，从而保证当某个硬盘出现故障时文件系统也能够正常运行。

使用RAID还可以在一定程度上提高读写磁盘的性能。实际情况中，通常将几块独立的硬盘组合在一起，形成一个逻辑上的RAID硬盘，这块硬盘在外界看来与RAID硬盘没有区别。

RAID功能已经内置在Linux2.0版本以及以后的版本内核中，在大多数Linux中，使用工具mdadm来管理RAID，用户可以从安装源下载并安装。

8.11.2 逻辑卷管理器：LVM

逻辑卷管理器可以将几个独立的硬盘组合成一个“卷组”。一个卷组有可以被分成几个“逻辑卷”，这些“逻辑卷”在外界看来就是一个个硬盘分区。管理员可以动态的增加逻辑卷的容量。

在大多数情况下，LVM被设置和RAID一起使用，管理员可以按照下面的顺序建立一个RAID+LVM的管理模式：

1）把多块硬盘组合成一个RAID硬盘

2）建立一个LVM卷组

3）把这个RAID硬盘加入到LVM卷组

4）在LVM卷组上划分逻辑卷

8.12 进阶3：备份你的工作和系统

本节主要介绍dump和restore工具。

8.12.1 为什么要做备份

对于大多数企业而言，存储在计算机中的数据远比计算机本身重要。

8.12.2 选择备份机制

备份需要考虑以下两个问题：

1）多长时间备份一次

2）是完整备份还是选择增量备份

8.12.3 选择备份介质

容量和稳定性是选择备份介质时首要考虑的问题，除此之外还需要兼顾成本。对于一些小型设备（如个人站点，台式计算机）的备份而言，刻录光盘或者移动硬盘这类价格低廉，容量较大，稳定性通常能保存在5年左右。

大型系统的备份则需要磁带机。这类存储介质具有容量大，保存时间长，适合于数据量大，更新频率高的环境。

最后一种方式是使用磁带库，这是一种带有多卷磁带机的大型设备。

对于大型企业而言，有必要为重要数据的备份寻找一个妥善的保管地点。

8.12.4 备份文件系统：dump

dump（还有配套的restore）默认并没有安装在Ubuntu以及OpenSUSE，用户需要去自己下载。

dump命令使用“备份级别”来实现增量备份，每次级别为N的备份会对从上次级别小于N的备份以来，修改过的文件执行备份。例如：

dump -0u -f /dev/nst0 /web      #执行从/web到/dev/nst0的0级备份

选项-0指定dump执行级别为0的备份。备份级别总共有10个（0～9），级别0表示完整备份。

选项-u指定dump更新/etc/dumpdates文件。该文件记录了历次备份的时间、备份级别和实施备份的文件系统，dump命令在实行增量备份的时候需要依据这个文件决定哪些文件应该备份。

选项-f指定了用于存放备份的设备，在这里是/dev/nst0，表示磁带设备。最后一个参数是需要备份的文件系统。

-u选项要求备份的必须是一个完整的文件系统。如果备份的是一个文件系统中的一个目录，则带有-u选项的dump会报错，并拒绝执行备份操作。

下面在/web下增加一个文件，这个文件的内容是根目录下的文件列表：

ls / > /web/ls_out

现在对/web执行一次3级备份：

dump -3u -f /dev/nst0/     /web       #执行从/web到/dev/nst0的3级备份

dump可以通过查看/etc/dumpdates，只需要备份上回0级备份以来修改过的文件就可以了。

dump命令只是简单的把需要备份的内容直接输出到目标设备上，而不会询问这个设备上已有的文件该如何处理。如果是磁带的话，必须确保当前磁头所在位置没有数据（或者本来就打算销毁这些数据），否则dump命令会把这些数据覆盖掉。这也是为什么不能选择块设备（如硬盘）作为增量备份的目标设备的原因。

如果试图从另一块硬盘上存储备份文件的话，那么第二次执行3级备份时，dump会把增量备份的文件输出到这个硬盘上，而之前0级备份中储存的的所有数据会被覆盖。

如果一定使用硬盘作备份的话，那么只能进行0级备份，下面命令以/dev/sdb3作为备份的目标设备为例：

dump -0 -f /dev/sdb3 /web       #在块设备上执行0级备份

dump工具有一个配套的rdump命令，用于将备份转储到远程主机上。需要指定远程主机名或者IP地址：

rdump -0u -f backup:/dev/nst0 /web

rdump通过SSH通道传输。

8.12.5 从灾难中恢复：restore

restore是dump的配套工具，用于从备份设备中提取数据。在restore恢复数据之前，首先要临时建立一个目录，首先需要建立一个临时目录，用于存放备份设备中的目录层次，用restore恢复的文件也会存放在这个目录下:

mkdir /var/restore     #建立恢复文件的目录

cd /var/restore        #进入这个目录

restore -i -f /dev/sdb3

执行完这条命令，restore会显示一个交互式的命令行界面。

用户可以使用ls和cd命令在备份的文件系统到处浏览，碰到需要的文件，就用命令add来标记它。最后用extra命令提取所有做过标记的文件和目录。

文件提取完成后，就可以使用quit命令退出restore。

/usr/local/sbin/restore > quit

通过查看当前目录（/var/restore）下的文件列表，可以看到恢复的文件。同时，restore在还原特定的文件时，还会还原完整的目录结构，如果用户不慎将整个文件系统都丢失了，可以使用带-r选项的restore命令恢复整个文件系统：

cd /web/

restore -r -f /dev/sdb3     #从/dev/sdb3恢复文件系统

类似的，rrestore命令从远程主机提取备份信息。下面命令以交互的方式从主机backup恢复由rdump转储的文件系统。

Rrestore -i -f backup:/dev/nst0

8.12.6 让备份定时自动完成：cron

通常来说，白天服务器都在繁忙运行，这个时间点来恢复和备份是不值得的。在夜间备份是个不错的选择，为了避免管理员三更半夜操作，使用cron提供的定时执行命令是个不错的选择。

 

# 第九章 用户与用户组管理

Linux作为一种多用户的操作系统，可以允许多个用户同时登陆到系统上，并响应每一个用户的请求。对用户账户管理是一项非常重要的工作，其中包括添加和删除用户、分配用户主目录、限制用户的权限。

 

9.1 用户与用户组基础

计算机通过用户提供的口令来验证用户的身份信息，这种简单有效的方式几乎广泛应用于所有的计算机系统。因此对管理员来说，一个合适的用户名和一个不易被破解的密码非常重要。

Linux利用用户提供的用户名和密码来进行验证，通过后为每一个用户提供一个进程，然后由这个进程接受用户的请求。在建立用户时，需要限制其权限，例如不能修改配置文件，不能查看其他用户目录。

可以将相似的用户或者具有相同属性的用户归在一起，这样的组被称为“用户组”。可以设定一个用户组的权限，这个组里的用户就自动拥有这些权限。

在某些服务器程序安装时，会生成一些特定的用户和用户组，用于对服务器进行管理。

9.2 快速上手：为朋友John添加账户

sudo useradd -m john       #添加一个名为john的用户，并自动建立主目录

处于安全考虑，在输入口令的时候，屏幕上并不会有任何显示（包括“*”号）。

sudo passwd john       #更改john的登陆密码

输入新的UNIX口令：

重新输入新的UNIX口令：

passwa:已成功更新密码

9.3 添加账户

9.3.1 使用命令行工具：useradd和groupadd

在默认情况下，不带-m参数的useradd命令不会为新用户建立主目录。在这种情况下，用户还能登陆到系统的shell，但不能登陆到图形界面。因为桌面环境无论是KDE还是GNOME，需要用到用户主目录中的一些配置文件。以下例添加一个用户nox：

useradd nox      #添加用户账号nox

passwd nox      #nox

输入新的UNIX口令：

重新输入新的UNIX口令：

passwd:已成功更新密码

使用当前账户nox用户账号登陆GNOME时，系统会提示无法找到用户主目录，并拒绝登陆。

如果在字符界面的2号控制台（Ctrl+Alt+F2）使用nox账号登陆，系统会引导nox用户进入根目录。此后，用户可以继续操作。

useradd命令中另一个常用的选项是-g。用于指定用户所属的组。下面命令用于建立名为mike的用户账号，并指定其所属组users组：

sudo useradd -g users mike

这样设置增加了由于不经意地设置权限而能够彼此读取文件的可能性，经常在用户创建时单独创建一个同名的用户组，然后将该用户归入指定的组。这正是不带-g参数的useradd命令的默认行为。

useradd的-s参数用于指定用户登陆后所使用的Shell。下面的命令建立名为mike的用户账号，并指定其登陆后使用bash作为shell：

sudo useradd -s /bin/bash mike

可以在/bin目录下找到特定的Shell。常用的有BASH、TCSH、ZSH（Z-Shell）、SH（Bourne Shell）等。如果不指定-s参数，那么默认使用sh（在大部分系统中，这是指向BASH的符号链接）登陆系统。

添加组可以使用groupadd命令，以下命令在系统中添加一个名为newgroup的组：

sudo groupadd newgroup

9.3.2 使用图形化的管理工具

除了传统的命令行工具，Linux还提供图形化工具对用户和用户组进行管理。图形化工具对用户提供了更友好的接口。以下以Ubuntu的“用户和组”进行介绍。

1）系统设置->用户和账号->解锁->输入管理员口令。

2）添加用户->创建新用户

3）输入用户名->创建->登陆选项->密码->更改此用户的密码->更改->设置密码

4）在“用户账户”中对个人的基本信息进行设置。

5）完成新用户的创建后，可以看到新用户出现在列表中。

9.3.3 记录用户操作：history

Linux中的Shell会记录用户的每一条命令。通过查看history命令：

history

history命令仅在BASH中使用，并列出所有使用过的命令并加以编号。这些信息被存储在用户的主目录.bash_history文件中，默认情况下可以存储1000条命令记录。为此，可以利用history列出最近几次输入的命令：

history 10    #列出最近使用的10条命令

但是，history只能列出当前用户的操作记录。对管理员来说，有时候需要查看其他用户的操作记录，此时可以读取该用户主目录下的.bash_history文件。例如查看用户john都干了什么：

cd /home/john    #进入john的主目录

sudo cat .bash_history     #查看.bash_history文件

.bash_history这个文件对其他受限用户是不可读的，这也是为什么要使用sudo的原因。

9.3.4 直接编辑passwd和shadow文件

在Linux中所做的一切基本配置最终都将反映到配置文件中，用户管理也不例外。

所有用户信息都登记在/etc/passwd文件中，而/etc/shadow文件则保存着用户的登陆密码。

可以通过手动编辑passwd和shadow这两个文件实现useradd等工具的所有功能。其中，passwd文件对所有用户可读，而shadow则只能用root账号查看。修改这两个文件都需要root权限。

9.4 删除用户：userdel

userdel命令用于删除用户帐号。例如删除milk账号：

sudo userdel milk

在默认情况下，userdel并不会删除用户的主目录。除非是使用了-r选项。以下命令删除账号john，同时删除其主目录：

sudo userdel -r john

一般情况下，将被删除用户的主目录保留几周，然后手动删除，在实际中显得尤为重要。

9.5 管理用户账户：usermod

可以使用usermod命令来修改已有的用户账号。这个命令有多个不同的选项，对应于账号的各个属性。下表列出了usermod命令的各个常用选项及其含义。

表9.1 usermod命令的常用选项

| 选项 | 含义                                                     |
| ---- | -------------------------------------------------------- |
| -d   | 修改用户主目录                                           |
| -e   | 修改账号的有效期限，以公元月/日/年的形式表示（MM/DD/YY） |
| -g   | 修改用户所属的组                                         |
| -l   | 修改用户账号                                             |
| -s   | 修改用户登陆后所使用的Shell                              |

下列命令将john改名为mike,主目录改为/home/mike，并设置账号有效期至2013年12月31日：

sudo usermod -l mike -d /home/mike -e 12/31/13 john

和useradd一样，usermod也可以通过修改/etc/passwd、/etc/shadow和/etc/group这3个文件来实现用户属性的设置。

9.6 查看用户信息：id

id命令用于查看用户的UID、GID及其所属的组。这个命令以用户名作为参数，下面这条命令显示了wangyan用户的UID、GID及其属于的组信息：

id wangyan

uid=1000(wangyan) gid=1000(wangyan) 组=1000(wangyan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare)

使用不带任何参数的id命令会显示当前登陆用户的信息。

9.7 用户间切换：su

不带任何参数的su命令会将用户提升至root权限，当然需要提供root口令。通过su命令所获取的特权也将一直持续到使用exit命令退出为止。

也可以使用su命令切换到其他用户，以下命令将当前身份转变为john：

su john

通过系统验证后，就可以访问john账号了。通过exit命令回到之前的账号。

9.8 受限的特权：sudo

使用su命令提升权限已经让系统安全得多了，但root权限的不可分割让事情变得棘手，对于某个用户需要执行一条特权语句而赋予完整的root权限，存在极大的安全隐患。

最常用的方法是使用sudo程序。该程序结合命令作为参数，并以root身份执行。处于安全考虑，用户在使用sudo之气需要输入一次口令，在默认时间段内无需再次输入口令。

管理员通过配置/etc/sudoers指定用户可以执行特权指令,在文件中，以“root ALL=(ALL)ALL”为例，指定root用户可以使用sodu在任何机器上（第一个ALL）以任何用户身份（第二个ALL）执行任何命令（第三个ALL）。其中一行配置用“%admin”替代了所有属于admin组的用户。在Unbuntu中，安装时创建的那个用户会自动被加入admin组。

总的来说，sudoer的权限说明包含以下内容：

1）该权限适用的用户

2）这一行配置在哪些主机上适用

3）该用户可以运行的命令

4）该命令应该以哪个用户身份执行

\# User privilege specification

root    ALL=(ALL:ALL) ALL

 

\# Members of the admin group may gain root privileges

%admin ALL=(ALL) ALL

以下是较为复杂的配置，涉及3个用户，并为他们设置了不同的权限：

Host_Alias     SATTION = web1,web2,databank

Cmnd_Alias    DUMP = /sbin/dump, /sbin/restore

lewis      STATION = ALL

mike       ALL = （ALL） ALL

john       ALL = (operator) DUMP

其中Host_Alias和Cmnd_Alias  分别定义了主机组和命令组，后面就可以用 SATTION代替主机组，用 DUMP代替命令组。这种设置可以让配置文件更清晰，同时也更容易维护。

sudoer中的路径应该使用绝对路径来指定，这样可以防止部分人利用root身份执行自己的脚本文件。

接下来的三行用于配置用户的权限，第一行中lewis可以在STATION组的计算机上（web1，web2，databank）执行任何命令。由于在代表命令的ALL之前没有使用小括号“（）”指定用户，因此lewis将以root身份执行这些命令。

第二行是关于用户的mike的配置信息，mike可以在计算机上运行任何命令。由于小括号“（）”中的用户列表使用了关键字ALL，因此mike可以用sudo以任何用户身份执行命令。可以使用带-u选项的sudo命令改变用户身份。例如mike可以以用户peter的身份建立文件：

sudo -u peter touch new_file

最后一行是关于用户john的配置信息，john可以在所有主机上执行/sbin/dump和/sbin/restore这两大命令—但必须以operator的身份。为此，john必须像这样使用dump命令：

sudo -u operator /sbin/dump backup /dev/sdb1

修改sudoers文件应该使用visudo命令。这个命令依次执行下面这些操作：

1）检查以确保没有其他人正在编辑这个文件

2）调用一个编辑器编辑该文件

3）验证并确保编辑后的文件没有语法错误

4）安装使sudoers文件生效

使用sudo虽然比su更加灵活与安全，但是实际上增加了系统中特权用户的数量，这样大大增加了系统的安全隐患。

9.9 进阶1：/etc/passed文件

本章简要介绍/etc/passwd文件，用于在Linux中存储用户信息。而用户的口令则存放在文件/etc/shadow中。

9.9.1 /etc/passwd文件概览

用户的基本信息被存储在/etc/passwd中，每一行代表一个用户，使用cat命令查看文件内容大致如下：

angyan@wangyan-ROG-Strix-G531GU-S5DU:~$ cat /etc/passwd

root:x:0:0:root:/root:/bin/bash

daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin

bin:x:2:2:bin:/bin:/usr/sbin/nologin

sys:x:3:3:sys:/dev:/usr/sbin/nologin

sync:x:4:65534:sync:/bin:/bin/sync

…

每一行由7个字段组成，字段间使用冒号分隔，各字段含义如下：

1)登陆名

2)口令占位符

3)用户ID号（UID）

4)默认组ID号（GID）

5)用户的私人信息：包括全名、办公室、工作电话、家庭电话等

6)用户的主目录

7)登陆Shell

9.9.2 加密的口令

在passwd的口令字段，只有口令占位符号“x”，由于passwd对所有用户可读，因此只能另找其它空间放置。如今绝大多数Linux均将用户口令文件加密后存在在文件/etc/shadow中，该文件只有root用户可以访问。

目前在Linux上使用最广泛的加密算法是MD5。

9.9.3 UID号

UID号用于唯一标识系统中的用户，这是一个32位无符号整数。Linux规定root用户的UID为0。而其他一些虚拟用户如bin、daemon等被分配到一些比较小的UID号，这些用户通常被安排在passwd文件的开头部分。一般真实用户的UID号都是从较大的数开始分配的。

应该保证每个用户UID号的唯一性，如果多个用户共一个UID号，那么诸如NFS这样的系统将会产生安全隐患。虽然可以有多个用户的UID号均为0，但出于安全方面考虑，一般不推荐这样做。

9.9.4 GID号

GID号用于在用户登陆时指定其默认所在的组。和UID号一样，也是一个32位整数。组在/etc/group文件中定义，其中root组的GID号为0。

在确定一个用户对某个文件是否具有访问权限时，系统会考察这个用户所在的所有组（在/etc/group文件中定义）。默认组ID只是在用户创建文件和目录时才有用。例如：john同时属于john、students、workmates这3个组，默认组是john。对于所有属于这3个组的文件和目录，john都有权访问。当john新建了一个文件，那么这个文件所属的组就是john。

9.10 进阶2：/etc/shadow文件

/etc/shadow用于存放用户加密后的口令，且为了保证安全性，该文件仅root用户可以访问，该文件中每一行代表一个用户，并以冒号分隔每一个字段，其中只有用户名和口令字段要求是非空的：

liuaihua:!:18494:0:99999:7:::

1）登陆名

2）加密后的口令

3）上次修改口令的时期

4）两次修改口令之间的天数（最少）

5）两次修改口令之间的天数（最多）

6）提前多少天提醒用户修改口令

7）在口令过期多少天后禁用该账户

8）账号过期的日期

9）保留，目前为空

在shadow中，绝对日期是1970年1月1日至今的天数，这个时间很难计算，但总是可以使用usermod命令来设置过期字段（以MM/DD/YY的格式）。下面这条命令设置用户的过期时间为2010年12月31日：

sudo usermod -e 12/31/2010

9.11 进阶3：/etc/group文件

/etc/group文件中保存有系统中所有组的名称，以及每个组中的成员列表。文件中的每一行代表一个组，由4个冒号分隔的字段组成，如下所示：

liuaihua:x:1002:

含义分别是：

1）组名

2）组口令占位符

3）组ID（GID）号

4）成员列表，用逗号隔开（不能加空格）

和passwd文件一样，如果口令字段为一个x的话，则表示另有一个/etc/gshadow文件用于存放组口令。一般该口令很少会用到，不必过于在意。

GID用于标识一个组，和UID一样，应该保证GID的唯一性。如果一个用户属于/etc/passwd中所指的某个组，但没出现在/etc/group文件相应的组中，那么应该以/etc/passwd文件中的设置为准。

实际上，用户所属的组是passwd文件和group文件中相应组的并集。但为了管理上的有序性，应该保持两个文件一致。

 

# 第十章 进程管理

10.1 快速上手：结束一个失控的程序

（1）在主目录中用文本编辑器创建一个名为badpro的文本文件，包含以下内容：

do

​    mkdir adir

​    cd adir

​    touch afile

 

​    sleep 2s

done

这是一个Shell脚本，该程序每隔2秒钟执行一次。

（2）将这个文件加上可执行权限，并从后台执行：

chmod +x badpro

./badpro

（3）该程序运行起来后，打开另一个终端，运行ps命令查看该程序的PID号（PID号用于唯一表示一个进程）：

pa aux | grep badpro

（4）使用命令kill杀死这个进程：

kill [进程的PID号]

（5）回到刚才运行badpro的终端，可以看到程序已经终止，最后将该程序建立的目录和文件删除：

rm -r adir

10.2 什么是进程

进程是操作系统的一种抽象概念，用来表示正在运行的程序。进程是系统资源分配的独立个体，每个进程都拥有独立的地址空间。读者可以把进程理解为正在运行的程序。

Linux是一种多用户，多进程的操作系统，在Linux中，维护着一张表，这张表记录了当前操作系统记录的所有进程的各种信息，Linux会自动完成对进程的控制和调度。内核中一些重要的信息如下：

（1）进程的内存地址

（2）进程当前的状态

（3）进程正在使用的资源

（4）进程的优先级（谦让度）

（5）进程的属主

Linux对用户提供了可以对进程进行监视和控制的工具。

10.3 进程的属性

10.3.1 PID：进程的ID号

系统为每个用户都分配了用于标识其身份的ID号（UID），同样的，进程也有这样的ID号，被称作PID。对计算机而言，认识数字永远比认识一串字符方便的多。

Linux不仅自己使用PID来确定进程，还要求用户在管理进程时也提供相应的PID号。几乎所有的进程管理工具都接受PID号。

10.3.2 PPID：父进程的ID

在Linux中，所有的进程都必须由另一个进程创建----除了在系统引导时，由内核自主创建并安装的那几个进程。当一个进程被创建时，创建它的那个进程被称作父进程，对应的，被创建的进程被称作子进程。PPID就等于其父进程的PID。

事实上在Linux中，进程是不能被“凭空”创建的，Linux并没有提供一种系统调用让应用程序“创建”一个进程。应用程序只能通过克隆自己来产生新进程。故而子进程应该是其父进程的克隆体。

10.3.3 UID和EUID：真实和有效的用户ID

只有进程的创建者和root用户才有权限对该进程进行操作，进程的UID就是其创建者的ID，用来标识进程的属主。

Linux还为用户保存了一个“有效用户ID号”，被称作EUID。这个特殊的UID用来确定进程对某些资源和文件的访问权限。在绝大情况下，进程的UID和EUID是一样的（除了著名的setuid程序）。

什么是setuid程序？以passwd为例，这个命令允许用户允许修改自己的登陆口令。但是密码保护在/etc/shadow文件中，这个文件对普通用户是不可访问的。setuid程序在passwd在执行阶段具有文件文件所有者（也就是root）的权限，让用户临时有了修改shadow文件的能力（尽管这种能力也是由限制的）。因此passwd就是一个典型的setuid程序，其UID是当前执行这个命令的用户ID，而EUID则是root用户的ID。

除此之外，Linux还给进程分配了其他几个UID，例如savedUID和FSUID。

10.3.4 GID和EGID：真实和有效的组ID

进程的GID是其创建者所属的的ID号，对应于EUID，进程同样拥有一个EGID号，可以通过setgid程序来设置。一个进程可以同时属于多个组，EGID在确定访问权限方面还发挥了一些作用。当进程需要创建一个新文件的时候，这个文件将采用该进程的GID。

10.3.5 谦让度和优先级

优先级高的进程能够被CPU更早的执行，能够获得更多的处理器时间。Linux内核会综合考虑一个进程的各种因素来决定其优先级，包括已经消耗的CPU时间以及进程的等待时间等。

用户可以通过设置进程的“谦让度”来影响内核的执行决策，“谦让度”与“优先级”正好相反，“谦让度”越高的进程被执行的时间的就越迟。

10.4 监视进程：ps命令

ps命令是最常用的监视进程的命令，这个命令给出了所有关于进程的有用信息。

在以往不UNIX系统上，ps命令的语法各不相同，为此Linux采取了折中的方式，目的是为了兼顾那些已经习惯其他系统上的ps命令用户。在绝大多数情况下，只需要用一种方式使用ps命令就可以了：

ps aux

ps aux命令用于显示当前系统上运行的所有进程的信息，以下仅取部分字段的具体含义：

表10.1 pa aux命令产生进程信息的各字段的含义

| 字段                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| USER                                                         | 进程创建者的用户名                                           |
| PID                                                          | 进程的ID号                                                   |
| %CPU                                                         | 进程占用CPU的百分比                                          |
| %MEM                                                         | 进程占用的内存百分比                                         |
| VSZ                                                          | 进程占用的虚拟内存大小                                       |
| RSS                                                          | 进程中页的数量（页是管理内存的单位，在PC上通常为4K）         |
| TTY                                                          | 进程所在终端的ID号                                           |
| STAT                                                         | 进程状态，常用字母代表的含义如下：  R正在运行中/可运行 D睡眠中（不可被唤醒，通常是在等待I/O设备）  S 睡眠中（可以被唤醒）T停止（由于受到信号或被跟踪）  Z 僵进程（已经结束而没有释放系统资源的进程） |
| 常用的附加标志有：  < 进程拥有比普通优先级高的优先级  N 进程拥有比普通优先级低的优先级  L 有些页面被锁在内存中  s 会话的先导进程 |                                                              |
| START                                                        | 进程的启动时间                                               |
| TIME                                                         | 进程已经占用的CPU时间                                        |
| COMMAND                                                      | 命令和参数                                                   |

 

ps的另一组选项lax可以提供父进程ID（PPID）和谦让度（NI）。ps lax命令不会显示进程属主的进程名，因此可以提供更快的运行速度（ps aux需要把UID转换为用户名后才输出）：

ps lax

10.5 即时跟踪进程信息：top命令

ps命令可以一次性给出当前系统中进程信息的快照，但这样的信息往往缺乏时效性，为此，Linux提供了top命令用于即时跟踪当前系统中进程的情况：

top

top命令显示的消息会占满一页，并且在默认情况下每10s更新一次。那些使用CPU最多的程序会排在最前面。用户还可以及时观察到当前系统CPU使用率、内存占用率等各种信息。最后使用q命令退出这个监视程序。

10.6 查看占用文件的进程：lsof

管理员有时候想知道某个特定的文件正被哪些进程使用。lsof命令能够提供包括PID在内的各种进程信息。不带任何参数的lsof命令会列出当前系统中所有打开文件的进程信息，要找出占用某个文件的进程，需要提供文件名作为参数。下列命令列出使用database.doc进程的相关信息：

lsof database.doc

10.7 向进程发送信号：kill

从本质上讲，kill命令只是用来向进程发送一个信号，至于这个信号是什么，则是由用户指定的。kill命令的标准语法如下：

kill [-signal] pid

Linux定义了几十种不同类型的信号，可以使用kill -l 命令显示所有信号及其编号。根据硬件体系结构不同，所显示的表也会有所不同：

kill -l

以下表格中列出了一些常用的信号名称及意义：

表10.2 常用的信号

| 信号编写       | 信号名 | 描述                 | 默认情况下执行的操作 |
| -------------- | ------ | -------------------- | -------------------- |
| 0              | EXIT   | 程序退出时收到该信号 | 终止                 |
| 1              | HUP    | 挂起                 | 终止                 |
| 2              | INT    | 中断                 | 终止                 |
| 3              | QUIT   | 退出                 | 终止                 |
| 9              | KILL   | 杀死                 | 终止                 |
| 11             | SEGV   | 段错误               | 终止                 |
| 15             | TERM   | 软件终止             | 终止                 |
| 取决于硬件体系 | USER1  | 用户定义             | 终止                 |
| 取决于硬件体系 | USER1  | 用户定义             | 终止                 |

 

在默认情况下，kill命令向进程发送TERM信号，这个信号表示请求终止某项操作。使用kill命令终止12974进程，等同于以下命令：

kill -TERM 12974

或者

kill -SIGTERM 12974

使用kill命令是否一定可以终止一个进程？答案是否定的，kill命令向程序“发送”一个信号，那么这个信号就应该能够被程序“捕捉”。程序可以“封锁”或者干脆“忽略”捕捉到的信号。只有在信号没有被程序捕捉的情况下，系统才会执行默认操作。

Linux中，快捷键Ctrl+C对应于信号INT。

在本章开头的badpro程序中只要能够忽略TERM信号，那么kill -TERM命令将对它不起作用。

新加入的命令“trap”“TERM”用于忽略TERM号，如果用户运行这个程序，可能会无法终止这个恶意程序。

幸运的是，有一个信号永远不能被程序所捕捉，这就是KILL信号，KILL可以在内核级别“杀死”一个进程，在绝大多数情况下，下面命令都可以确保结束进程为pid的进程：

sudo kill -KILL pid

或者

sudo kill -SIGKILL pid

或者

sudo kill -9 pid

对于一些极其顽强的进程，以至于KILL信号都不能影响他们，这种情况常常是由一些退化的I/O（输入输出）虚假锁定造成的。此时，重启系统是解决问题的唯一方法。

10.8 调整进程的谦让度：nice和renice

nice命令可以在启动程序时设置其谦让度，高谦让度意味着低优先级。谦让度的值应该在-21～19之间浮动。

nice通过接受一个-n参数增加程序的谦让度。下面以不同的谦让度启动bc程序，并使用ps lax命令观察其谦让度（NI）的值：

\##设置bc以谦让度增量2启动

nice -n 2 bc

ps lax

\##设置bc以谦让度增量-3启动

sudo nice -n -3 bc

ps lax

\##不带-n参数的nice命令会将程序的谦让度增量设置为10

nice bc

ps lax

与之相对的，renice命令可以在进程运行时调整其谦让度值，下面这条命令将bc程序的谦让度值调整为12：

ps lax  #获得进程的PID

renice +12 -p 8567  #-p选项指定进程的PID

ps lax      #观察效果

以上主要讲解nice和renice命令时的不同用语，“谦让度增量”值的是nice命令将-n参数后面的数值加上默认谦让度值，作为程序的谦让度值。也就是说，nice命令调整的是“相对”谦让度值。renice是调整“绝对”谦让度值的，通常来说，程序的默认谦让度值总是0，这种情况下就不必考虑“相对”和“绝对”的问题了。保险起见，应该使用不带任何参数的nice命令查看这个“默认”谦让度值：

nice    

如果用户不采取任何操作，那么新进程将继承父进程的谦让度，进程的属主可以提高其谦让度，但不能降低其谦让度。root用户可以任意设置进程的优先级。

10.9 /PROC文件系统

/PROC是一个非常特殊的文件系统，或者说它根本不是什么文件系统，/PROC目录下存放着内核有关的各种有意义的信息，系统运行的时候，内核会随时向这个目录写入数据。ps和top就是从这个地方读取数据的。这是操作系统向用户提供了一条通往内核的通道，用户甚至可以通过向/proc目录下的文件写入数据来修改操作系统参数。

/PROC目录下以数字命名的目录存放着以该数字为PID的进程的信息。

 

# 第十一章 网络配置

11.1 几种常见的连网方式

桌面用户关心的是如何接入网络，而不是接入具体是如何实现的，因此，本节将完全从用户的角度考察接入互联网的方式。

11.1.1 通过办公室局域网

在一座或一群建筑物之间存在的网络通常被称为“局域网”。常见的英文缩写LAN(Local Area Network)表达的是同一个意思。

目前，几乎所有的局域网都使用了以太网技术，以太网是一种基于载波侦听、多路访问和冲突检测的连网协议。尽管存在有多种形式的以太网，但其基本原理是一致的。

11.1.2 无线连接

如果正在使用笔记本电脑，那么无线接入方式会是一个很不错的选择。无线连网正在经历一个快速发展的阶段，这个领域已经有了很多不同的标准，其中IEEE的802.11g和802.11a无线局域网标准是目前使用最广泛的无线连网标准。

11.1.3 有线宽带连接

更多的人在更多的时候选择在家中上网。目前国内的宽带普及率已经相当高，这种高普及率已经推动了整个互联网行业的飞速发展。DSL是数字用户线路（Digital Subscriber Line）的缩写。这种技术使用普通电话线传输数据。使用DSL需要到电信公司申请，并由电信公司派遣人员上门安装。这种安装主要包括一个机盒，这个机盒提供了到计算机的一条以太网连接。目前国内主要使用的DSL技术分支是ADSL。A代表非对称（asymmetric），简单的说就是上传和下载的速度不同。

11.1.4 “古老”的拨号上网

目前仍有部分用户在使用古老的拨号上网方式。这种上网方式要求一台被称为调制解调器（Modem）的设备，将电话模拟信号转变为计算机可理解的的数字信号。出于内容完整性的考虑，本节内容仍然加入了拨号上网的内容。

11.2 连接PC至局域网和Internet

11.2.1 连接办公室局域网

如果局域网使用的是动态主机配置协议(DHCP)，用户只需将网线插上计算机，Linux就会自动向DHCP服务器租用各种网络和管理参数，包括IP地址，网络掩码，默认网关和域名服务器等。要配置当前网卡使用DHCP方式，可以遵循下面的步骤：

（1）单击“设置”按钮，选择“系统设置”命令，在“系统设置”对话框中选择“网络”命令，打开“网络”对话框。

（2）选择“有线”选项，单击选项“按钮，弹出“正在编辑Wired connection1”对话框，在弹出的对话框中选择“IPV4”选项卡。

（3）在“方法”下拉列表框中选择自动配置(DHCP)选项，单击“保存”按钮。

（4）静态IP的配置方法稍微复杂一点，在“方法”下拉列表框中选择“手动”选项，然后单击“添加”按钮，并依次输入IP地址，子网掩码，网关地址字段，输出完后单击“保存”按钮。

11.2.2 使用ADSL

ADSL是当前家庭用户使用最多的的互联网接入方式。

 

1.Ubuntu中的设置

ADSL使用以太网PPPoE调制解调器设置实现连接。这是一种被称作“点对点”的拨号方式。要配置Ubuntu使用ADSL上网，可以简要参照以下步骤：

（1）打开终端模拟器，输入命令“sudo pppoeconf“，打开”点对点“连接配置工具。这是一种基于文本的菜单程序，首先应该保证检测到了所有的以太网设备。

（2）如果没有问题，使用方向键将光标点位到“是“按钮，按”Enter“键进入下一步，pppoeconf会要求用户确认和配置有关下信息，简单的回答”是“即可，接下来输入用户名和口令。此时口令是明文形式显示的。

（3）随后pppoeconf会询问用户是否将获取的DNS信息加入本地列表中。回答“是“即可，并对接下来的”MSS限制错误“对话框同样回答”是“。

（4）至此就完成了对宽带连接的配置。是否在每次启动时建立连接和是否立即建立连接完全取决于用户自己的想法。

以后可以使用下面命令建立连接：

sudo pon dsl-provider

相应地，下面这条命令关闭该PPP连接：

sudo poff dsl-provider

 

2.openSUSE中的设置

openSUSE用户可以使用YAST2配置工具设置ADSL连接。

（1）通过选择桌面左下角的“K菜单“|”计算机“|”YaST2“命令，打开YaST2控制中心，定位到”网络设备“标签。

（2）单击DSL图标，弹出“DSL配置概述“对话框，单击”添加“按钮，打开”DSL配置“对话框。

（3）在“PPP方式“下拉列表框中选择”基于以太网的ppp“选项，单击”下一步“按钮，此时系统弹出”选择因特网服务提供商(ISP)“对话框，要求用户选择服务提供商。

（4）在弹出的“提供程序参数“对话框中依次输入”提供商名称“、”用户名“和”密码“字段。

（5）单击“下一步“按钮，设置连接参数，通常只要保持默认值就可以了。

（6）最后YAST2会显示汇总信息，单击“完成“按钮结束配置。YAST2会替用户完成所有的设置。

（7）右击桌面右下角的电源图标，在弹出的快捷菜单中选择“拨入“命令即可建立连接。如果找不到这个图标，可以选择桌面左下角”K菜单“|”因特网“|”因特网拨号“命令打开这个拨号软件。

11.2.3 无线网络

随着无线热点覆盖的范围越来越广，移动办公已经走进了寻常百姓的生活，要在Linux下使用无线网络，首先需要安装无线网卡的驱动程序。无线网卡是少有几种对Linux支持不太友好的硬件设备，各大无线网卡制造商似乎对提供Linux下的驱动并不积极。

一种被称为Ndiswrapper的程序能够利用Windows上的网卡驱动程序配置Linux内核。Ubuntu中提供了该工具，用户可以直接使用agt-get安装。安装无线网卡具体步骤如下：

（1）将无线网卡自带的光盘插入光驱中

（2）找到该光盘上的手动运行安装程序。

（3）安装完成后，单击“设置“按钮，在弹出的”系统设置对话框“中选择”网络“命令打开这个软件。

通常来说，安装完成后，无线网卡只要使用默认设置就可以了。Linux会自动捕捉当前所在区域的无线接口。

11.2.4 拨号上网

拨号上网的障碍主要来自于Modem的驱动程序。如果读者使用的是外置拨号调制解调器，那么Linux不需要驱动程序就可以识别。如果遇到了需要在Windows下的特定驱动程序才能够正确运行的Modem，那么只能到Internet上去碰运气。

安装完驱动后，通过以下配置完成拨号上网连接：

（1）选择Ubuntu右上角连接图标，右击“编辑连接“命令，弹出”网络连接“对话框。

（2）在弹出的“网络连接“对话框中选择DSL选项卡，然后单击”添加“按钮，在弹出的”正在编辑DSL连接 1“对话框中选择”IPV4设置“选项卡，在方法下拉列框中选择”自动（PPPoE）“命令。

（3）在“正在编辑DSL连接 1“对话框中选择”PPP设置“命令可以对认证方法、压缩方式等选项进行设置。

11.3 进阶1：在命令行下配置网络

11.3.1 使用ifconfig配置网络接口

Ifconfig命令用于启动或禁用一个网络接口，同时设置其IP地址、子网掩码以及其他网络选项。通常，ifconfig在系统启动时通过接受相关配置文件中的参数完成网络配置。用户也随时可以使用这个命令改变当前网络接口的设置。

下面这条例子将网络接口eth0的IP地址设置为192.168.1.14，子网掩码为255.255.255.0，同时启动这个网络接口：

sudo ifconfig eth0 192.168.1.14 netmask 255.255.255.0 up

eth0这个名字标识了一个网络硬件接口。其中的eth代表Ethernet，即以太网。第一个以太网接口为eth0，第2个以太网接口为eth1…...以此类推。无限网络接口往往以wlan开头，遵循和以太网接口相同的命名法则。

eth0后面紧跟着IP地址。netmask选项指导ifconfig命令设置网络接口的子网掩码。

IP地址是一个长达4字节的二进制数，用于唯一标识网络上的主机。通常每个字节被转换成一个十进制数，各数字之间用点号隔开。IP地址的表示分为网络部分和主机部分，其中网络部分表示地址所指的逻辑网络，而主机部分则表示该网络中的一台计算机。

这样问题就产生了：即便前三个字节都作为网络部分使用（即N.N.N.H的形式），仍然有多达254个主机号可供这个网络分配。如果网络部分采用2个字节（N.N.H.H）和1个字节（N.H.H.H）,那么这个数字将分别达到65536和16777214。对于一个逻辑网络而言，主机数通常不会超过100台，预留那么多主机号显然是一种浪费，子网掩码应运而生，通过对IP地址和子网掩码实施“与”运算，可以将网络号分离开来，从而实现利用有限的IP地址划分更多逻辑网络的目的。最后的关键字up用于启动网络接口。与之相反的是关键字down，用于关闭该网络接口：

sudo ifconfig eth0 down

可以使用不带任何参数的ifconfig命令显示当前系统上所有网络接口的配置：

wangyan@wangyan-ROG-Strix-G531GU-S5DU:~$ ifconfig

eno2: flags=4099<UP,BROADCAST,MULTICAST> mtu 1500

​    ether 04:d4:c4:e4:10:f2 txqueuelen 1000 (以太网)

​    RX packets 0 bytes 0 (0.0 B)

​    RX errors 0 dropped 0 overruns 0 frame 0

​    TX packets 0 bytes 0 (0.0 B)

​    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

 

lo: flags=73<UP,LOOPBACK,RUNNING> mtu 65536

​    inet 127.0.0.1 netmask 255.0.0.0

​    inet6 ::1 prefixlen 128 scopeid 0x10<host>

​     loop txqueuelen 1000 (本地环回)

​    RX packets 416 bytes 41260 (41.2 KB)

​    RX errors 0 dropped 0 overruns 0 frame 0

​    TX packets 416 bytes 41260 (41.2 KB)

​    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

 

wlo1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500

​    inet 192.168.1.5 netmask 255.255.255.0 broadcast 192.168.1.255

​    inet6 2409:8a20:836:4710:e5da:9ca:3695:6834 prefixlen 64 scopeid 0x0<global>

​    inet6 fe80::dbf4:79b1:f3e6:1142 prefixlen 64 scopeid 0x20<link>

​    inet6 2409:8a20:836:4710:546e:d28a:133:8051 prefixlen 64 scopeid 0x0<global>

​    ether 0c:dd:24:a6:66:57 txqueuelen 1000 (以太网)

​    RX packets 1456 bytes 534290 (534.2 KB)

​    RX errors 0 dropped 0 overruns 0 frame 0

​    TX packets 1539 bytes 254645 (254.6 KB)

​    TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

名为lo的网络接口，lo表示“环回网络”，这是一个没有实际硬件接口的虚拟网络。127.0.0.1这个环回地址始终指向当前主机，也可以使用localhost表示当前主机。

如果正在远程服务器使用ifconfig命令，那么应该随时提防因为操作不慎而把自己断了。

11.3.2 使用route配置静态路由

路由是定义网络上两台主机间如何通信的一种机制。为了实现与目的主机的通信，需要告诉本地主机遵循怎样一条线路才能够到达目的地。Linux内核中维护着一张路由表，每当一个数据包需要被发送时，Linux会把这个包的目标IP地址和路由表中的路由信息比较。如果找到了匹配的表项，那么这个包就会被发送到这条路由所对应的网关。网关会负责把这个包转发到目的地。

使用netstat -r命令可以看到当前系统中的路由信息：

wangyan@wangyan-ROG-Strix-G531GU-S5DU:~$ netstat -r

内核 IP 路由表

Destination   Gateway     Genmask     Flags  MSS Window irtt Iface

default     192.168.1.1   0.0.0.0     UG    0 0     0 wlo1

link-local   0.0.0.0     255.255.0.0   U     0 0     0 wlo1

192.168.1.0   0.0.0.0     255.255.255.0  U     0 0     0 wlo1

处于同一个网络之间的主机不需要网关即可到达。default表示一条默认路由，当所有表项都不能被匹配的时候，Linux会把包转发到default对应的网关上。

route命令用于增加或删除一条路由，以下命令增加一条默认路由：

sudo route add default gw 10.71.84.2

关键字add表示增加路由表项，关键字default表示这是一条默认路由，关键字gw告诉Linux后面紧跟的参数是包应该被转发到的那台主机（也就是网关）。

可以手动配置路由信息，使主机能够访问某个网络。例如现在希望连接到一个网络地址为10.62.74.0/24的网络。在本地网络中有一台IP地址为10.71.84.51的主机可以作为网关。那么运行下面这条命令增加一条路由：

sudo route add -net 10.62.74.0/24 gw 10.71.84.51

-net表示后面紧跟着的是一个网络地址，也就是目的网络。 10.62.74.0/24表示通过子网掩码提取的网络部分。对应的子网掩码为255.255.255.0。

也可以使用-host关键字指定紧跟的IP地址是一个主机地址。下面这条命令将所有发送到主机10.62.74.4的包，转发到网关10.71.84.51上：

sudo route add -host 10.62.74.4 gw 10.71.84.51

IP地址一般表示一台主机，但是全0和全1的主机地址会被保留作为网络地址和广播地址i，网络地址代表整个网络，而发送到广播地址的包会被转发到这个网络的所有主机上。

可以指定对某个特定的网络接口配置路由表：

sudo route add -host 10.62.74.4 gw 10.71.84.51 dev eth0

关键字dev是可有可无的，route命令也能理解下面这种说法：

sudo route add -host 10.62.74.4 gw 10.71.84.51 eth0

最后，使用del命令可以删除一条路由，下面这条命令删除当前默认路由：

sudo route del default

在远程登陆的情况下，删除路由表项应该格外注意。

11.3.3 主机名和IP地址之间的映射

IP地址太长且难以记忆，因此使用主机名来标识一台计算机就显得自然而然了，主机名是用来方便人们记忆的一串有意义的字符串。计算机并不能通过主机名确定计算机的位置，计算机必须通过IP地址才能确定主机。因此需要一种法方式来确定主机名和IP地址之间的映射关系。

最流行的是DNS，客户端通过发起查询获得某台主机的IP地址。另一种较为原始的方式是使用hosts文件。尽管hosts文件在网络中很少应用，但是hosts文件中指定本地映射关系在系统引导的时候非常必要。

Linux下的hosts文件保存在/etc目录下，一个典型的hosts文件应该至少包含两行，分别指定localhost和本地主机名对应的IP地址。例如：

wangyan@wangyan-ROG-Strix-G531GU-S5DU:~$ cat /etc/hosts

127.0.0.1 localhost

127.0.1.1 wangyan-ROG-Strix-G531GU-S5DU

可以编辑这个文件加入新的映射关系，例如下面指明一台名为data-keeper的主机IP地址为10.10.10.31:

10.10.10.31 data-keeper

11.4 进阶2：使用wvdial建立PPP连接

本节主要介绍和PPP连接的有关知识，以及如何通过wvdial拨号工具建立一条PPP连接。

11.4.1 PPP协议简介

PPP协议（Point-to-Point Protocol，点到点协议）是目前应用最广泛的数据传输协议之一，例如家用的ADSL中就使用了这一技术，在最简单的情况下，PPP通过下面这几步建立网络连接：

（1）使用串行调制解调器拨号

（2）登陆远程主机（通常是运营商的接入服务器）

（3）启动远程PPP协议引擎

（4）将串行端口配置为网络端口

这也是一般拨号上网的基本过程：家庭用户通过PPP在用户端和运行商的接入服务器之间建立通信链路。随着ADSL等宽带接入方式的普及，PPP逐渐衍出更多的应用，如ADSL使用的PPPoE（PPP over Ethernet）等。

11.4.2 wvdial简介

Shell下配置PPP比较麻烦，用户需要自己编写对话脚本。各个版本的Linux在配置文件和命令上也不一致。

wvdial能够自动使用合理的参数，并根据用户提供的用户名，口令和电话号码调用PPP连接。

11.4.3 配置wvdial

wvdial配置文件是/etc/wvdial.conf，这个配置文件中定义了拨号使用的调制解调器、用户名、口令和电话号码。除了调制解调器外，其他信息都应该从运行商处获取。通常来说，调制解调器对应的设备文件是/dev/moderm。

11.4.4 使用wvdial拨号上网

如果简单的使用命令wvdial，那么wvdial会使用[Dialer Defaults]中定义的规则尝试建立连接。或者也可以给wvdial提供一个参数，参数应该是wvdial.conf中某个Dialer段的名字。

在建立连接的过程中，Linux会在屏幕上打印一系列信息作为反馈。如果没有出现错误提示的话，一条拨号连接就建立起来了。直到用户使用Ctrl+C快捷键关闭连接。

 

# 第十二章 浏览网页

12.1 使用Mozilla Firefox

12.1.1 启动Firefox

Firefox是目前所有Linux都自带的默认浏览器。

Firefox的特色之一是在与标签式的浏览方式，用户不需要在浏览网页时打开多个浏览窗口，页面间的切换可以通过选择标签来完成。双击标签栏的空白部分，或者使用Ctrl+T快捷键可以打开一个空白标签。

用户在打开多个网页的情况下试图关闭浏览器时，Firefox会给出提示，询问是否确认关闭窗口。

12.1.2 设置Firefox

选择“编辑”|“首选项”命令中可以对Firefox的各种选项进行设置。其中最常用的功能是“主要”选项卡，其中可以设置Firefox启动时显示的页面，根据读者的喜爱，可以设置为显示主页、显示空白页、显示上次关闭时的页面。

Firefox在默认情况下将下载的文件保存到“下载”文件夹下面，用户可以自由更改默认的存储位置，也可以通过选定“总是询问保存文件的位置”单选框让“Firefox”在每次下载文件的时候都询问保存路径。

如果需要代理服务器，首先安装Suse Linux系统。系统安装完成后，在终端用ifconfig命令查看是不是有eth0 eth1两块网卡，在这里用eth0作为外网网卡，eth1作为内网网卡。由于本节内容均在图形界面操作，故不作详细介绍。

1）配置IP

2）输入网关

3）启动防火墙

12.1.3 清除最新的历史记录

Firefox提供了一个功能能够清除保存在浏览器中的浏览记录。

在这里需要解释以下cookie，用户在浏览网页时，一些服务器会在用户机器的特定目录（由浏览器指定）下存储一些信息。这些信息往往用于确定用户的身份，这些信息非常短小，因此被形象的成为cookie（英语小甜饼的意思）。cookie由浏览器管理，可以设置失效时间。

12.1.4 订阅新闻和微博

RSS是在线共享内容的一种简易方式（也叫聚合内容，Really Simple Syndication）。网站通过RSS输出，可以让用户获取到网站内容的最新更新。

具体操作本处不做介绍。

现如今几乎所有的的博客和新闻类网站都提供了RSS订阅功能。

12.1.5 安装扩展组件

作为一款开源软件，Firefox每天都有大量的扩展组件被开发出来。

具体安装添加扩展组件本初也不作详细介绍。

12.2 使用Opera

与Firefox一样，Opera也支持多页面标签式浏览，Opera支持多国语言，并且能在大多数系统平台上运行。可以从官网下载Opera的最新版本。

12.3 基于文本的浏览器：lynx

12.3.1 为什么还要使用字符界面

在图形化界面如此普及的背景下，字符界面的浏览器确实没有什么存在的必要了，但是在有时候图形界面奔溃，又希望上网查看下载资料的时候，Lynx会是一个很好的选择。

12.3.2 启动和浏览

尽管Lynx没有包含在各大发行版的默认安装中，但在大部分的Linux发行版的安装包中都包含这个软件，可以使用包管理工具直接安装。

启动Lynx只需要打开终端，输入Lynx即可，也可以将网址作为参数打开网页。可以通过方向键控制光标移动，Lynx会逐个加亮超链接文本，在文本高亮时按回车键会进入对应网页。

在浏览网页时，Lynx会给出操作提示，使用空格键可以快速向下滚动屏幕。

如果用户没有输入任何内容就回车，那么Lynx将回到当前页面。

12.3.3 下载和保存文件

在Lynx中下载文件非常方便，移动光标使得链接高亮显示，

12.4 其他浏览器