本章内容包括：
  is-a关系的继承
  如何以公有方式从一个类派生出另一个类
  保护访问
  构造函数成员初始化列表
  向上和向下强制转换
  虚成员函数
  早期(静态)联编与晚期(动态)联编
  抽象基类
  纯虚函数
  何时以及如何使用公有继承

13.1 一个简单的基类
  从一个类派生出另一个类，原始类称为基类，继承类称为派生类

  派生类存储了基类的数据成员(派生类继承了基类的实现)
  派生类对象可以使用基类的方法(派生类继承了基类的接口)

  派生类需要自己的构造函数
  派生类可以根据自己的需要添加额外的数据成员和成员函数

  构造函数必须给新成员和继承的成员提供函数
  派生类不能直接访问基类的私有成员，必须通过基类方法进行访问。
  派生类构造函数必须使用基类构造函数


  派生类构造函数要点
  首先创造基类对象
  派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
  派生类构造函数应初始化派生类新增的数据成员

  派生类可以使用基类的方法，前提是基类方法不是私有的
  基类指针可以在不进行显示类型转换的情况下指向派生类对象：基类引用可以在不进行显示类型转换的情况下引用派生类对象
  基类指针或引用只能用于调用基类方法，不可以调用派生类方法。
  不可以将基类对象和地址赋给派生类引用和指针

13.2 继承：is-a关系
  C++有3种继承方式：
  公有继承
  保护继承
  私有继承

  公有继承不建立has-a关系
  公有继承不能建立is-like-a关系
  公有继承不建立is-implemented-as-a(作为...来实现)
  公有继承不建立uses-a关系

13.3 多态公有继承
  多态：同一个方法在派生类和基类中的行为是不同的，方法的行为取决于调用该方法的对象

  实现多态公有继承的机制：
  在派生类中重新定义基类的方法
  使用虚方法 virtual

13.4 静态联编和动态联编
  函数名联编将源代码中的函数调用解释为执行特定的函数代码块

  在编译过程中进行联编被称为静态联编，又称为早期联编
  虚函数的出现增加了静态联编的难度
  编译器在动态联编，也称为晚期联编中生成能够在程序运行时选择正确的虚函数的代码。

  通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型。

  向上强制转换：将派生类引用或指针转换为基类引用或指针
  向下强制转换：将基类引用或指针转换为派生类引用或指针，如果不使用显示类型转换，则向下强制转换是不允许的。

  隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来动态联编

  为什么又两种类型的联编以及为什么默认为静态联编
  效率：静态联编的效率更高，因此被设置为C++的默认选择
  概念模型：仅将那些预期将被重新定义的方法声明为虚的

  虚函数的工作原理
  C++规定了虚函数的行为，但将实现方法留给了编译器作者。
  编译器处理虚函数：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。该数组称为虚函数表。(virtual function table, vtbl)

  构造函数不能是虚函数
  析构函数应当是虚函数
  友元不能是虚函数，因为友元不是类成员，只有类成员才能是虚函数。

  返回类型协变：允许返回类型随类类型的变化而变化，例如重新定义继承方法，如果返回类型是基类引用或者指针，可以修改为指向派生类的引用或指针。
  这种例外只适用于返回值，不适用于参数。

13.5 访问控制:protected
  关键字 protected 与 private 相似，在类外只能用公有类成员来访问 protected 部分中的类成员。
  protected 和 private 之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。

13.6 抽象基类
  C++通过纯虚函数提供未实现的函数。
  纯虚函数声明的结尾处为=0
  virtual double Area() const = 0; // a pure virtual function

  当类声明中包含纯虚函数时，不能创建该类的对象。
  包含纯虚函数的类只用作基类。但C++甚至允许纯虚函数有定义。

  抽象类中至少有一个纯虚函数。
  可以将 ABC 看作是一种必须实现的接口，ABC 要求具体派生类覆盖其纯虚函数。

13.7 继承和动态内存分配
  基类中使用了 new 和 delete 进行动态内存分配和回收，派生类中应当如何处理？
  当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。

  派生类如何使用基类的友元？
  通过强制类型转换，以便匹配原型时能够选择正确的函数。

13.8 类设计回顾

  按值传递对象设计到生成临时拷贝，即调用复制构造函数，然后调用析构函数。

  *：关于子类继承带有参数的父类的构造函数的初始化问题，如下
  class subclass( const subclass & pc ) ： public parentclass(...)
  {
    ...
  };
