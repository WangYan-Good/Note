9.1 单独编译
  程序文件包含三个部分：
  头文件：包含结构声明和使用这些结构的函数原型
  源代码文件：包含与结构有关的函数的代码
  源代码文件：包含调用与结构相关的函数的代码

  软件包的构成：一个文件(头文件)包含了用户定义类型的定义，另一个文件包含操纵用户定义类型的函数的代码

  头文件中常包含的内容：
  函数原型
  使用#define或const定义的符号常量
  结构声明
  类声明
  模板声明
  内联声明

  如果文件名包含在尖括号中，例如<stdio.h>，则编译器将在存储标准头文件的主机系统中查找
  如果文件名包含在双引号中，例如"stdio.h"，则编译器将首先查找当前的工作目录或源代码目录，如果没有找到目标文件，则将在标准位置查找

  #include用于管理头文件，但是也同时导致多重声明
  可以使用#idndef(if not defined)来避免多次包含同一个头文件

9.2 存储持续性、作用域和链接性
  数据存储在内存中的时间区别
  自动存储连续性:函数定义中声明的变量，在函数开始执行时被创建，函数执行完毕时内存被释放
  静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量，它们在整个运行过程中都存在
  线程存储持续性：对于CPU处理多任务时使得程序能够将计算放在可并行处理的不同线程中，如果使用关键字thread_local声明，则其声明周期与所属的线程一样长
  动态存储持续性：使用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止

  作用域(scope)：描述了名称在文件的多大范围内可见

  链接性(linkage)：描述了名称如何在不同单元间共享
  自动变量的名称没有链接性，因为它们不能共享

  在C++11中，关键字auto用于自动类型判断，它用于显式的指出变量为自动存储
  1.自动变量的初始化

  2.自动变量和栈
  一般保留一段内存，将其视为栈，栈具有LIFO(先进后出)的特性，用于保存临时变量

  3.寄存器变量
  关键字register最初由C语言引入，它建议编译器使用CPU寄存器来存储自动变量
  旨在提高访问变量的速度
  在C++11中，关键字register失去了提示作用，只是显示地指出变量是自动的。

  C++为静态存储持续性变量提供了3种链接性：
  外部链接性(可在其他文件中访问)
  内部链接性(只在当前文件中访问)
  无链接性(只能在当前函数或代码块中访问)

  编译器分配固定的内存单元统一管理静态变量
  编译器会将没有显示初始化的静态变量设置为0

  constexpr:创建常量表达式方式的关键字

  单定义规则：在C++中，变量只能有一次定义
  C++提供了两种变量声明：
  定义声明(defining declaration)：给变量分配存储空间
  引用声明(reference declaration)：引用已有的变量，不给变量分配存储空间

  引用声明使用关键字 extern, 且不进行初始化，否则会导致分配存储空间

  定义与全局变量同名的局部变量后，局部变量会隐藏全局变量
  C++提供了作用域解析运算符(::),该运算符表示使用使用变量的全局版本

  存储说明符(storage class specifier)
  auto(在C++11中不再是说明符)
  register
  static
  extern
  thread_local
  mutable:即使某个成员是const类型，也可以修改

  cv-限定符(cv-qualifier)
  const
  volatile:即使程序代码没有对内存单元进行修改，其值也可能发生变化

  语言链接性
  C语言和C++编译器对函数名的翻译规则不同，可以使用语言链接性指出翻译规则，例如：
  extern "C" void spiff(int);
  extern void spiff(int);
  extern "C++" void spiff(int);

  C++动态内存由new和delete管理，而不是由作用域和链接性规则控制

  编译器使用3块独立的内存
  一块用于静态变量：固定内存
  一块用于自动变量：栈
  一块用于动态存储：堆

  动态分配内存与回收
  typename funcname = new {buffer} typename/typename[size];
  delete funcname;

  对于静态存储区，位于delete的管辖区域之外，delete只能用于常规new运算符分配的堆内存

9.3 名称空间
  C++提供了名称空间工具，以便于更好地控制名称的作用域

  C++中已有的名称空间属性
  声明区域(declaration region)：可以在其中进行声明的区域

  潜在作用域(potential scope)：变量的潜在作用域从声明点开始，到其声名区域的结尾
  潜在作用域比声明区域小，变量必须定义后才能使用

  C++中关于全局变量和局部变量的规则定义了一种名称空间层次

  C++通过定义一种新的声明区域来创建命名的名称空间，提供一个声明名称的区域，使得名称空间中的名称不会与另外名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。

  名称空间中声明的名称的链接性一般为外部的。

  全局名称空间(global namespace):对应于文件级声明区域

  using声明将特定的名称添加到它所属的声明区域中
  using编译指令导入一个名称空间的所有名称，使所有的名称都可用

  编译器不允许同时使用两个using声明，这将导致二义性

  名称空间可以嵌套

  老式头文件(如iostream.h)没有使用名称空间，但新头文件iostream使用了std名称空间

